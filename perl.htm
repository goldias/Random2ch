<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Shift_JIS"><LINK REV=MADE HREF="mailto:ohzaki@din.or.jp"><TITLE>Perlメモ</TITLE></HEAD><!--IMG SRC="update.gif" ALT="Update" WIDTH=60 HEIGHT=12--><!--IMG SRC="new.gif" ALT="New" WIDTH=28 HEIGHT=11--><BODY BGCOLOR="#FFF8DC"><!--BODY BGCOLOR="cornsilk"--><H1><A NAME="Top">Perlメモ</A></H1>更新日 2002/8/25<BR><IMG SRC="http://cnt1.din.or.jp/cgi-bin/Count.cgi?st=4404&dd=C&ft=0&frgb=0;0;0|df=ohzaki_1.dat" ALT="カウンター" ALIGN=CENTER WIDTH=90 HEIGHT=20><SCRIPT LANGUAGE="JavaScript"><!--  window.document.write("<IMG SRC=\"http://cgi.din.or.jp/~ohzaki/nph-cntr.cgi?");  window.document.write(window.document.referrer);  window.document.write("\" WIDTH=1 HEIGHT=1>\r\n");  if (document.URL.match(/perl.ja/)) {    location.href = "perl.htm";  }// --></SCRIPT><NOSCRIPT></NOSCRIPT><BR><BR><A HREF="index.htm">戻る</A><HR><A HREF="regex.htm">Perl正規表現雑技</A>へ<HR><H3>更新履歴</H3>2002/08/25 「<A HREF="#Character">文字の正規表現</A>」スクリプトと文章追加<BR>2002/07/29 「<A HREF="#Mail">メールアドレスの正規表現</A>」リンク追加<BR>2002/06/05 「<A HREF="#JP_RmSpace">前後の空白文字(全角スペース含)を削除する</A>」スクリプトのバグ修正<BR>2002/02/22 「<A HREF="#Tag_Remove">タグを削除する</A>」文章追記<BR>2002/01/20 「<A HREF="#HTML_Tag"><NOBR>HTMLタグ</NOBR>の正規表現</A>」スクリプト改良と文章大幅修正<BR><A NAME="Index"><HR></A><H2>目次</H2><!--IMG SRC="update.gif" ALT="Update" WIDTH=60 HEIGHT=12--><!--IMG SRC="new.gif" ALT="New" WIDTH=28 HEIGHT=11--><TABLE><TD><UL>  <LI><A HREF="#First">はじめに</A>  <HR>  <LI>ファイル    <UL>      <LI><A HREF="#File_Lock">排他制御(ファイルロック)をする</A>      <LI><A HREF="#File_Reverse">ファイルの中身を逆順に表示する</A>      <LI><A HREF="#File_Tail">ファイルの最後の数行だけ表示する</A>      <LI><A HREF="#File_Random">ファイルから        <NOBR>1行</NOBR>ランダムに選択する</A>      <LI><A HREF="#File_DirSize">ディレクトリ(フォルダ)サイズを求める</A>    </UL>  <LI>HTML    <UL>      <LI><A HREF="#Tag_Remove">タグを削除する</A>      <LI><A HREF="#AutoLink">自動で URI(URL) のリンクを張る</A>    </UL>  <LI>正規表現    <UL>      <LI><A HREF="#Character">文字の正規表現</A><IMG SRC="update.gif" ALT="Update" WIDTH=60 HEIGHT=12>      <LI><A HREF="#HTML_Tag"><NOBR>HTMLタグ</NOBR>の正規表現</A>      <LI><A HREF="#URI">URI(URL) の正規表現</A>      <LI><A HREF="#httpURL"><NOBR>http URL</NOBR> の正規表現</A>      <LI><A HREF="#ftpURL"><NOBR>ftp URL</NOBR> の正規表現</A>      <LI><A HREF="#Mail">メールアドレスの正規表現</A>    </UL><LI><A NAME="JP">日本語を扱う</A>    <UL>      <LI><A HREF="#JP_EUC_JP">        perl スクリプトは <NOBR>EUC-JP</NOBR> で書く</A>      <LI><A HREF="#JP_Trans">        漢字コードを <NOBR>EUC-JP</NOBR> に変換して処理する</A>      <LI><A HREF="#JP_Code">漢字コードを調べる</A>      <LI><A HREF="#JP_Exist">全角文字が含まれているか判定する</A>      <LI><A HREF="#JP_Cut">文字が途切れているか判定する</A>      <LI><A HREF="#JP_Z2H">全角英数字を半角英数字に変換する</A>      <LI><A HREF="#JP_HK2ZK">半角カタカナを全角カタカナに変換する</A>      <LI><A HREF="#JP_Match">正しくパターンマッチさせる</A>      <LI><A HREF="#JP_RmSpace">前後の空白文字(全角スペース含)を削除する</A>      <LI><A HREF="#JP_Split">文字単位に分割する</A>      <LI><A HREF="#JP_Fold">特定の長さで折り返す</A>      <LI><A HREF="#JP_Base64">        <NOBR>Base64</NOBR>エンコード・デコードする</A>        <DL>          <DD>例 ←→ <NOBR>=?ISO-2022-JP?B?GyRCTmMbKEI=?=</NOBR>        </DL>      <LI><A HREF="#JP_Escape">        URIエスケープ・アンエスケープする</A>        <DL>          <DD>エスケープ ←→ <NOBR>%a5%a8%a5%b9%a5%b1%a1%bc%a5%d7</NOBR>        </DL>    </UL>  <LI>改行コード    <UL>      <LI><A HREF="#CRLF_Unify">改行コードを統一する</A>      <LI><A HREF="#CRLF_2BR">        改行コードを <NOBR>&lt;BR&gt;</NOBR> に変換する</A>      <LI><A HREF="#CRLF_Remove">改行コードを削除する</A>    </UL>  <LI><NOBR>CSV(Comma Separated Value)</NOBR>    <UL>      <LI><A HREF="#CSV2Values">        <NOBR>CSV形式</NOBR>の行から値のリストを取り出す</A>        <DL>          <DD><NOBR>値1,値2,&quot;値3,値3&quot;,&quot;値4&quot;&quot;値4&quot;</NOBR> →              <NOBR>値1 値2 値3,値3 値4&quot;値4</NOBR>        </DL>      <LI><A HREF="#CSVwithCRLF">値に改行コードを含む        <NOBR>CSV形式</NOBR>を扱う</A>      <LI><A HREF="#CSVfromValues">値のリストから        <NOBR>CSV形式</NOBR>に変換する</A>        <DL>          <DD><NOBR>値1 値2 値3,値3 値4&quot;値4</NOBR> →              <NOBR>値1,値2,&quot;値3,値3&quot;,&quot;値4&quot;&quot;値4&quot;</NOBR>        </DL>    </UL>  <LI>ソート    <UL>      <LI><A HREF="#SortST">特定の項目でソートする</A>      <LI><A HREF="#SortMulti">複数の項目でソートする</A>      <LI><A HREF="#SortOriginal">自分で決めた順番でソートする</A>    </UL>  <LI>年月日・曜日    <UL>      <LI><A HREF="#Date2WDay">年月日から曜日を求める</A>      <LI><A HREF="#Time2Date">一週間前の年月日を求める</A>      <LI><A HREF="#Date2Last">年月から末日を求める</A>      <LI><A HREF="#NthW2Date">第N W曜日の日付を求める</A>    </UL>  <LI>数字    <UL>      <LI><A HREF="#NumberWithComma">数字を 3桁ごとにコンマで区切る</A>        <DL>          <DD><NOBR>1234567890 → 1,234,567,890</NOBR>        </DL>      <LI><A HREF="#NumberRound">数字を四捨五入する</A>      <LI><A HREF="#NumberCeil">数字を切り上げる</A>    </UL>  <LI>配列    <UL>      <LI><A HREF="#ArrayUnique">配列から重複した要素を取り除く</A>      <LI><A HREF="#ArrayRandom">配列をランダムに並び替える</A>    </UL></UL><TD WIDTH="4%"></TABLE><A HREF="#Top">トップへ</A><A NAME="First"><HR></A><H2>はじめに</H2><TABLE><TD><UL>  <LI>このページは <A HREF="misc.htm#Perl"><NOBR>Perl5</NOBR></A>    を対象としています．    また，<FONT COLOR="Red">perl を対象</FONT>としていますので，    jperl で動くという保証はありません．  <LI>perl スクリプトは <FONT COLOR="Blue"><NOBR>EUC-JP</NOBR>    で書かれることを想定</FONT>しています．  <LI>このページは<A HREF="http://forest.ne.jp/cgi-ml/">    CGIメーリングリスト</A>    などでの質疑応答・FAQを参考に，私が独自にメモとしてまとめたものです．    ただし，CGI に特化したものではありません．  <LI>主に参照させていただいたページは私のページ    (<A HREF="misc.htm">雑多なリンク</A>) の    <A HREF="misc.htm#Character">文字</A>／    <A HREF="misc.htm#Perl">Perl</A>／    <A HREF="misc.htm#WWW">WWW</A> にリンクを張ってあります．  <LI>このページに書かれているスクリプトは，    個人の責任において実行してください．また，    随時不具合の修正をしていますので，ご利用される方はご注意ください．  <LI>このページに書かれているスクリプトの    <FONT COLOR="Blue">利用・改造は自由</FONT> です．    その際はどこかにこのページの    URI(<A HREF="http://www.din.or.jp/~ohzaki/perl.htm">    <NOBR>http://www.din.or.jp/~ohzaki/perl.htm</NOBR></A>    )を参考として記述していただければ幸いです(任意)．  <LI>このページは <NOBR>Internet Explorer 5</NOBR> および    <NOBR>Netscape Communicator 4.75</NOBR>    で表示の確認を行っています．これら以外のブラウザをご使用の場合は，    正常に表示されないかもしれません．  <LI>ご意見・ご感想・ご要望などは<A HREF="mailto:ohzaki@din.or.jp">    <NOBR>ohzaki@din.or.jp</NOBR></A>にお願いします．こう書いた方がいい，    動かん，わからん，バグってる，これ書け，などなどお待ちしています．  <LI>このページへの <FONT COLOR="Blue">リンクは自由</FONT>    に張ってくださって結構です．URI は    <FONT COLOR="Red">    <NOBR>http://www.din.or.jp/~ohzaki/perl.htm</NOBR></FONT>    です．  <LI>引用または転載する場合は，出典としてこのページの    URI(<A HREF="http://www.din.or.jp/~ohzaki/perl.htm">    <NOBR>http://www.din.or.jp/~ohzaki/perl.htm</NOBR></A>    )を明記してください．    URI を明記する場合に限り許可は必要ありませんが，    事後でかまわないのでお知らせくださればうれしいです．    URI を明記しない場合には事前の許可なしに引用または転載することを    禁止 します．</UL><TD WIDTH="4%"></TABLE><A HREF="#Top">トップへ</A><A NAME="File_Lock"><HR></A><H2>排他制御(ファイルロック)をする</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE>sub my_flock {  my %lfh = (dir =&gt; './lockdir/', basename =&gt; 'lockfile',	     timeout =&gt; 60, trytime =&gt; 10, @_);  $lfh{path} = $lfh{dir} . $lfh{basename};  for (my $i = 0; $i &lt; $lfh{trytime}; $i++, sleep 1) {    return \%lfh if (rename($lfh{path}, $lfh{current} = $lfh{path} . time));  }  opendir(LOCKDIR, $lfh{dir});  my @filelist = readdir(LOCKDIR);  closedir(LOCKDIR);  foreach (@filelist) {    if (/^$lfh{basename}(\d+)/) {      return \%lfh if (time - $1 &gt; $lfh{timeout} and	  rename($lfh{dir} . $_, $lfh{current} = $lfh{path} . time));      last;    }  }  undef;}sub my_funlock {  rename($_[0]-&gt;{current}, $_[0]-&gt;{path});}# ロックする(タイムアウトあり)$lfh = my_flock() or die 'Busy!';# アンロックするmy_funlock($lfh);</PRE></B></BLOCKQUOTE><P>複数のプロセスが同時にある <NOBR>1つ</NOBR>のファイルを読み書きする可能性がある場合，<FONT COLOR="Blue">排他制御</FONT>をしなければなりません．排他制御をする方法はいくつかありますが，このスクリプトは次の方針に基づいています．<OL>  <LI>どんなプラットフォームでも使えること  <LI>異常なロック状態を回避できること</OL><P>排他制御をする方法として <NOBR><CODE>flock</CODE> 関数</NOBR> や<NOBR><CODE>symlink</CODE> 関数</NOBR>を使う方法がありますが，これらの関数はプラットフォームによってはサポートされていません．したがって，1 を満たすためにはこれらの方法を使うことはできません．それ以外の方法としては，<NOBR><CODE>mkdir</CODE> 関数</NOBR>を使う方法と<NOBR><CODE>rename</CODE> 関数</NOBR>を使う方法が考えられます．次に 2 についてですが，異常なロック状態とは，あるプロセスがロックした状態のまま何らかの原因で死んだ場合に，ロックが解除されずに残ってしまった状態のことです．<CODE>flock</CODE> を使っている場合は，ロック状態でプロセスが死んだとき<FONTCOLOR="Blue">自動的にロックが解除</FONT>されますので，異常なロック状態は起こりません．しかし， <CODE>symlink</CODE> や<CODE>mkdir</CODE>， <CODE>rename</CODE> などを使う場合にはスクリプト側での対処が必要になります．<P>具体的にどのように対処するかですが，ロック状態がある一定の時間を経過していた場合には異常と判断し，他のプロセスがロック状態を解除してもよいことにします．実はここに落とし穴が存在します．排他制御をする方法としてなぜ<CODE>symlink</CODE> や <CODE>mkdir</CODE>， <CODE>rename</CODE> を使うのか？それはこれらの関数が，<FONT COLOR="Red">ロックできるかどうかのテストと実際にロックする操作を同時に行なうことができる atomic な関数</FONT>であるからです．話を戻して，異常なロック状態を解除するときのことを考えます．たとえば，<CODE>mkdir</CODE> を使ったロックの方法において，異常なロック状態のときにロックを解除するには，次のようなスクリプトになります．<BLOCKQUOTE><PRE>rmdir($lockdir) if (time - (stat($lockdir))[9] &gt; 60);</PRE></BLOCKQUOTE><P>ロック状態が <NOBR>60秒</NOBR>以上経過していた場合にはロックを解除するというスクリプトですが，これが <CODE>symlink</CODE> や <CODE>mkdir</CODE>，<CODE>rename</CODE> のときと違って，ロックを解除するかどうかの判断と実際にロックを解除する操作を同時に行なっているわけではないということが問題となります．具体的に何がまずいのかというと，<FONT COLOR="Red">正常なロック状態も解除してしまうことがある</FONT>ということです．それは次のような場合です．<BLOCKQUOTE><TABLE BORDER=1><TR><TH>プロセスＡ<TH>プロセスＢ<TH>プロセスＣ<TR><TD>異常と判断<TD>異常と判断<TD><CENTER>↓</CENTER><TR><TD><CENTER>↓</CENTER><TD><CENTER>↓</CENTER><TD><CENTER>↓</CENTER><TR><TD><CENTER>ロック解除</CENTER><TD><CENTER>↓</CENTER><TD><CENTER>↓</CENTER><TR><TD><CENTER>↓</CENTER><TD><CENTER>↓</CENTER><TD><CENTER>ロック</CENTER><TR><TD><CENTER>↓</CENTER><TD><CENTER>ロック解除</CENTER><TD><CENTER>↓</CENTER></TABLE></BLOCKQUOTE><P>複数のプロセスでロック状態が異常であると判断し，そのうちの<NOBR>1つ</NOBR>がロックを解除したことにより，別のプロセスがロックしたにもかかわらず，先ほどロック状態が異常であると判断したプロセスによってこの正常なロックを解除されてしまう可能性があります．<P>この方法の問題点は，異常なロック状態を解除する操作が正常なロック状態をも解除できてしまうことにあります．逆に言えば，異常なロック状態を解除する操作によって正常なロック状態を解除できなければ問題ないわけです．そのためにはどうすればよいのか？ 答えは<FONT COLOR="Red">ロック状態が常に変化していけばよい</FONT>ということです．そして，これを実現するのに都合がよいのが<CODE>rename</CODE> による方法になります．<P>最初のスクリプトで説明しますと，ロックファイルが <TT>lockfile</TT> という名前のときがロックが解除されている状態で，<TT>lockfile987654321</TT> のように後ろに作成時刻がついた状態がロック状態になります．こうすることで先ほどの例で，<NOBR>プロセスＢ</NOBR>によって<NOBR>プロセスＣ</NOBR>のロックが解除されてしまったという状況を回避することができます．なぜなら，<NOBR>プロセスＣ</NOBR>によって <CODE>rename</CODE> されたロックファイルの名前はすでに<NOBR>プロセスＢ</NOBR>が知っている名前とは違っているからです．最初のスクリプトでは一旦ロックを解除するのではなく，異常なロック状態を解除しつつ，新たなロック状態へと移行させています．<P>スクリプトの注意点としては，あらかじめロック用のディレクトリとファイルを用意しておくこと，ディレクトリに書き込み属性をつけておくこと，<CODE>dir</CODE> の値には最後に <CODE>/</CODE> などのデリミタをつけておくことです．<NOBR><CODE>$lfh = my_flock(basename =&gt; 'lockfileA');</CODE></NOBR>のように呼び出すことでパラメータを変更できます．また，<CODE>my_flock()</CODE>はロックに失敗(タイムアウト)すると <CODE>undef</CODE> を返します．ロックするまでブロックしたい場合には次のように書きます．<BLOCKQUOTE><B><PRE># ロックする(タイムアウトなし)1 while (not defined($lfh = my_flock()));</PRE></B></BLOCKQUOTE><P>最後に，ファイルを読み込み，それを加工した上で書き込む場合の安全な排他制御の手順を書いておきます．<OL>  <LI>ロックする  <LI>ファイルを読み込む  <LI>一時ファイルに書き込む  <LI>一時ファイルを元ファイルにリネームする  <LI>アンロックする</OL></BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="File_Reverse"><HR></A><H2>ファイルの中身を逆順に表示する</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># ファイル $file の中身を逆順に表示する$bufsize = 1024;open(FILE, &quot;&lt; $file&quot;);binmode(FILE);$size = (-s FILE) / $bufsize;$pos += $size &lt;=&gt; ($pos = int($size));while ($pos--) {  seek(FILE, $bufsize * $pos, 0);    read(FILE, $buf, $bufsize);  $buf .= $buf_tmp;  ($buf_tmp, @lines) = $buf =~ /[^\x0D\x0A]*\x0D?\x0A?/g;  pop(@lines);  foreach (reverse @lines) {    print $_;    print &quot;\n&quot; if $_ !~ /[\x0D\x0A]$/;  }}close(FILE);print $buf_tmp;</PRE></B></BLOCKQUOTE><P>このスクリプトはファイルを <NOBR><CODE>$bufsize</CODE> バイト</NOBR>ずつ読み込んで逆順に表示するので，ファイル全体を一度に読み込む方法に比べて<FONT COLOR="Red">少ないメモリ</FONT>で実行させることができます．<P><NOBR><CODE>$size</CODE></NOBR> への代入文にある<FONT COLOR="Red"><NOBR><CODE>-s</CODE></NOBR></FONT>は<FONT COLOR="Blue">ファイルテスト演算子</FONT>の<NOBR>1つ</NOBR>でファイルサイズを返します．<NOBR><CODE>$pos</CODE></NOBR> にはファイルサイズを<NOBR><CODE>$bufsize</CODE></NOBR>で割って切り上げた値が代入されます．切り上げに関しては「<A HREF="#NumberCeil">数字を切り上げる</A>」を参照してください．<NOBR><CODE>while</CODE> ブロック</NOBR>は <NOBR><CODE>$pos</CODE>回</NOBR>に分けてファイルを読み込んで処理するということをやっています．<P><NOBR><CODE>$buf</CODE></NOBR>には <NOBR><CODE>$bufsize</CODE> バイト</NOBR>ずつ読み込んだファイルの一部が代入されます．ファイルの中身を逆順に表示するためには，まずは <NOBR><CODE>$buf</CODE></NOBR> の中身を行ごとに分ける必要があります．それを行なっているのが<NOBR><CODE>$buf =~ /[^\x0D\x0A]*\x0D?\x0A?/g;</CODE></NOBR> の部分になります．この正規表現は，改行コード以外の文字が <NOBR>0文字</NOBR>以上続き，その後の改行コードまでを表わしています．つまり，これで <NOBR>1行</NOBR>分を取り出しているわけです．改行コード以外の文字が <NOBR>0文字</NOBR>以上であるので空行にもマッチします．また，改行コードの部分の正規表現<NOBR><CODE>\x0D?\x0A?</CODE></NOBR> は改行コードが<NOBR><CODE>\x0D\x0A</CODE></NOBR> でも <NOBR><CODE>\x0D</CODE></NOBR> でも<NOBR><CODE>\x0A</CODE></NOBR> でもよいことはもちろんのこと，ファイルの最後が改行で終わっていない行だった場合にもマッチします．ここまでの話ですでにお気づきの人もいるかもしれませんが，この<NOBR>1行</NOBR>分にマッチする正規表現は，実は<FONT COLOR="Red">空文字列にもマッチ</FONT>します．そして，それは必ず <NOBR><CODE>$buf</CODE></NOBR> の最後でマッチさせる文字が何もない状態で一度だけ起こります．したがって，この無意味な空文字列を削除するために，次の行で<NOBR><CODE>pop(@lines);</CODE></NOBR> しています．<P><NOBR><CODE>$buf</CODE></NOBR> の中身を行ごとに分けるには<NOBR><CODE>split</CODE> 関数</NOBR>を使って，<NOBR><CODE>split(/\x0D\x0A|\x0D|\x0A/, $buf);</CODE></NOBR> とすればいいのではないかと思うかもしれませんが，この方法では <NOBR><CODE>$buf</CODE></NOBR> の最後に空行があった場合にまずいことになります．<NOBR><CODE>split</CODE> 関数</NOBR>の<NOBR>第 3引数</NOBR>を省略すると，<CODE>split</CODE> した結果の<FONT COLOR="Red">最後が空文字列であった場合には自動的に削除</FONT>されます．つまり，最後に空行が連続する文字列<NOBR><CODE>&quot;foo\nbar\n\n\n&quot;</CODE></NOBR> のようなものを<CODE>split</CODE> すると<NOBR><CODE>('foo', 'bar')</CODE></NOBR> しか残らないため，本来<NOBR><CODE>('foo', 'bar', '', '')</CODE></NOBR>となってほしかった最後の空行がなくなってしまいます．<P>そこで最後の空文字列を自動的に削除させないために，<NOBR>第 3引数</NOBR>に<NOBR><CODE>split(/\x0D\x0A|\x0D|\x0A/, $buf, -1);</CODE></NOBR>のように<FONT COLOR="Blue">負数を指定</FONT>すればいいのではないかと思うかもしれませんが，これでもまだうまくいきません．例えば，<NOBR><CODE>&quot;foo\nbar\n&quot;</CODE></NOBR> を<CODE>split</CODE> すると，今度は <NOBR><CODE>('foo', 'bar', '')</CODE></NOBR>のように最後の改行コードの後ろの空文字列が削除されずに残ってしまいます．そこで，これに対処するために最後が空文字列であった場合には削除するように，<NOBR><CODE>pop(@lines) if $lines[-1] eq '';</CODE></NOBR> とする手があります．しかし，これを行なうことによって，ちょうど<NOBR><CODE>$bufsize</CODE></NOBR> ずつ区切った前後が改行コードであった場合には必要な空行まで削除してしまいます．そのためさらに，<CODE>read</CODE> の後に<NOBR><CODE>$buf_tmp = &quot;\n&quot; if $buf_tmp eq '';</CODE></NOBR>を入れる必要があります．これで正規表現を使った方法とほぼ同じ動作をするようになります．ただ，私がベンチマークをとって調べたところ，正規表現を使った方法の方が<FONT COLOR="Blue">速かった</FONT>ためそちらを採用しました．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="File_Tail"><HR></A><H2>ファイルの最後の数行だけ表示する</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># ファイル $file の最後の最大 $n行だけ表示する$bufsize = 1024;open(FILE, &quot;&lt; $file&quot;);binmode(FILE);$size = (-s FILE) / $bufsize;$pos += $size &lt;=&gt; ($pos = int($size));while ($pos--) {  seek(FILE, $bufsize * $pos, 0);    read(FILE, $buf, $bufsize);  $buf .= $buf_tmp;  ($buf_tmp, @lines) = $buf =~ /[^\x0D\x0A]*\x0D?\x0A?/g;  pop(@lines);  unshift(@tail, @lines);  last if @tail &gt;= $n;}close(FILE);unshift(@tail, $buf_tmp);@tail = @tail[-$n .. -1] if @tail &gt; $n;foreach (@tail) {  print $_;}</PRE></B></BLOCKQUOTE><P>このスクリプトの基本は「<A HREF="#File_Reverse">ファイルの中身を逆順に表示する</A>」のスクリプトと同じです．スクリプトの詳細についてはそちらを参照してください．違いとしては<NOBR><CODE>$n</CODE> 行</NOBR>を取り出すことができた時点ですぐに<NOBR><CODE>while</CODE> ブロック</NOBR>を抜けるようにしているところです．<P>実際に表示する直前では <NOBR><CODE>@tail</CODE></NOBR> の大きさを調べ，もし<NOBR><CODE>$n</CODE></NOBR> よりも大きければ最後の<NOBR><CODE>$n</CODE> 個</NOBR>だけを<FONT COLOR="Red">配列スライス</FONT>で取り出して代入し直しています．<FONT COLOR="Red"><NOBR><CODE>..</CODE></NOBR></FONT>は<FONT COLOR="Blue">範囲演算子</FONT>と言い，<FONT COLOR="Red">リストコンテキスト</FONT>で実行した場合は範囲演算子の前の値から後ろの値までのリストを返します．つまり，この場合は<NOBR><CODE>(-$n, -$n+1,..., -2, -1)</CODE></NOBR> というリストになります．配列の添え字が負数だった場合には後ろから数えた場所になるので，この場合は配列の最後の <NOBR><CODE>$n</CODE> 個</NOBR>分ということになります．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="File_Random"><HR></A><H2>ファイルから <NOBR>1行</NOBR>ランダムに選択する</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># ファイル $file から 1行ランダムに選択するsrand;open(FILE, &quot;&lt; $file&quot;);rand($.) &lt; 1 and $line = $_ while &lt;FILE&gt;;close(FILE);print $line;</PRE></B></BLOCKQUOTE><P>このスクリプトではファイル全体をメモリに読み込まないので<FONT COLOR="Red">少ないメモリ</FONT>で実行させることができます．また，ファイルの行数があらかじめわかっている必要もありません．<P>ファイル全体に対して <NOBR><CODE>while</CODE> 文</NOBR>を回すわけですが，<NOBR>1行</NOBR>ずつ読み込んで実行される部分が <CODE>while</CODE>よりも左側の部分です．この部分は <NOBR>2つ</NOBR>の式の <CODE>and</CODE>を取っています．<FONT COLOR="Blue"><NOBR>論理演算子 <CODE>and</CODE></NOBR></FONT>は左側が真の場合に限り右側が評価されます．つまり，この部分は<NOBR><CODE>if</CODE>文</NOBR>を使って次のように書いたものと同じ意味になります．<BLOCKQUOTE><PRE>if (rand($.) &lt; 1) {  $line = $_;}</PRE></BLOCKQUOTE><P><FONT COLOR="Blue"><NOBR>特殊変数 <CODE>$.</CODE></NOBR></FONT>は最後に読み込んだファイルの行番号を返します．したがって，この条件が成立する確率は <NOBR><CODE>1/$.</CODE></NOBR> になります．たとえば，<NOBR>1行目</NOBR>のときは <NOBR>1/1</NOBR>，<NOBR>2行目</NOBR>のときは <NOBR>1/2</NOBR>，<NOBR>3行目</NOBR>のときは <NOBR>1/3</NOBR> の確率というようになります．これでなぜランダムに <NOBR>1行</NOBR>選択できるのかという問題は数学の問題です．簡単に書きますと，全部で <NOBR>3行</NOBR>のファイルだった場合に，<NOBR>1行目</NOBR>が選択されるのは，<NOBR>1行目</NOBR>で条件が真となり，<NOBR>2行目</NOBR>と<NOBR>3行目</NOBR>では条件が偽となる必要があります．したがって，確率は <NOBR>1/1 * (1 - 1/2) * (1 - 1/3) = 1/3</NOBR> となり，ちゃんと行数で割った確率になります．<NOBR>2行目</NOBR>が選択されるのは，条件が <NOBR>2行目</NOBR>で真で <NOBR>3行目</NOBR>で偽の場合です．<NOBR>2行目</NOBR>で真になればそれ以前の条件は無関係だというのはいいですよね？ その結果，確率はやはり <NOBR>1/2 * (1 - 1/3) = 1/3</NOBR> となり，行数で割った確率になります．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="File_DirSize"><HR></A><H2>ディレクトリ(フォルダ)サイズを求める</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># ディレクトリ $dir のサイズ $size を求めるuse File::Find;find(sub {$size += -s if -f}, $dir);print $size, &quot;bytes\n&quot;;</PRE></B></BLOCKQUOTE><P>このスクリプトは<NOBR>ディレクトリ <CODE>$dir</CODE></NOBR> 以下のすべてのファイルのファイルサイズの合計を求めています．あるディレクトリ以下のすべてのファイルまたはディレクトリに対して何か処理したい場合には<FONT COLOR="Blue"><NOBR>標準モジュール <CODE>File::Find</CODE></NOBR></FONT> の <NOBR><CODE>find</CODE> 関数</NOBR>を使うのが簡単です．この関数は<NOBR>第 2引数</NOBR>で与えたディレクトリに対して，ファイルまたはディレクトリを<FONT COLOR="Blue">幅優先</FONT>で探索し，見つかったファイルまたはディレクトリを <NOBR><CODE>$_</CODE></NOBR> に<NOBR>1つ</NOBR>代入しては<NOBR>第 1引数</NOBR>で与えた関数を実行します．正確には<NOBR>第 1引数</NOBR>には<FONT COLOR="Red">関数へのリファレンス</FONT>を与えます．このスクリプトでは<FONT COLOR="Blue">無名関数へのリファレンス</FONT>を与えています．これは次のように書いても同じです．<BLOCKQUOTE><PRE># ディレクトリ $dir のサイズ $size を求める(わかりやすく)use File::Find;find(\&amp;wanted, $dir);print $size, &quot;bytes\n&quot;;sub wanted {  $size += -s $_ if -f $_;}</PRE></BLOCKQUOTE><P><FONT COLOR="Red"><NOBR><CODE>-s</CODE></NOBR></FONT>は<FONT COLOR="Blue">ファイルテスト演算子</FONT>の <NOBR>1つ</NOBR>でファイルサイズを返します．<FONT COLOR="Red"><NOBR><CODE>-f</CODE></NOBR></FONT>はディレクトリやシンボリックリンクなどではなく普通のファイルのときに真となります．幅優先ではなく<FONT COLOR="Blue">深さ優先</FONT>で処理したい場合には <NOBR><CODE>finddepth</CODE> 関数</NOBR>を使います．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="Tag_Remove"><HR></A><H2>タグを削除する</H2><BLOCKQUOTE><P><NOBR><CODE>$str</CODE></NOBR> は<FONT COLOR="Blue"><NOBR>EUC-JP</NOBR> という前提</FONT>ですので，必要ならばあらかじめ <NOBR>EUC-JP</NOBR> に変換しておいてください．漢字コードの変換に関しては「<A HREF="#JP_Trans">漢字コードを <NOBR>EUC-JP</NOBR>に変換して処理する</A>」を参照．<BLOCKQUOTE><B><PRE># $str の中のタグを削除した $result を作る# $tag_regex と $tag_regex_ は別途参照$text_regex = q{[^&lt;]*};$result = '';while ($str =~ /($text_regex)($tag_regex)?/gso) {  last if $1 eq '' and $2 eq '';  $result .= $1;  $tag_tmp = $2;  if ($tag_tmp =~ /^&lt;(XMP|PLAINTEXT|SCRIPT)(?![0-9A-Za-z])/i) {    $str =~ /(.*?)(?:&lt;\/$1(?![0-9A-Za-z])$tag_regex_|$)/gsi;    ($text_tmp = $1) =~ s/&lt;/&amp;lt;/g;    $text_tmp =~ s/&gt;/&amp;gt;/g;    $result .= $text_tmp;  }}</PRE></B></BLOCKQUOTE><P>このスクリプトの基本は「<A HREF="#AutoLink">自動で URI(URL) のリンクを張る</A>」のスクリプトと同じです．詳しくはそちらを参照してください．<NOBR><CODE>$tag_regex</CODE></NOBR>および <NOBR><CODE>$tag_regex_</CODE></NOBR> については「<A HREF="#HTML_Tag"><NOBR>HTMLタグ</NOBR>の正規表現</A>」のスクリプトを正規表現として使います．また， <NOBR><CODE>$str</CODE></NOBR> には<FONT COLOR="Red"><NOBR>HTML文書</NOBR>全体</FONT>を入れておきます．注意が必要な点としましては，<NOBR>XMPタグ</NOBR>や <NOBR>PLAINTEXTタグ</NOBR>を削除した場合には，それまでその中で無効だったタグが有効になってしまう可能性があることです．そのため，<NOBR>XMPタグ</NOBR>や <NOBR>PLAINTEXTタグ</NOBR>を削除するときには，その中の <CODE>&lt;</CODE> を <NOBR><CODE>&amp;lt;</CODE></NOBR> に，<CODE>&gt;</CODE> を <NOBR><CODE>&amp;gt;</CODE></NOBR>に変換しています．<NOBR>SCRIPTタグ</NOBR>についても同様です．<P>次のようにしてタグの開始 &lt; と終了 &gt;にだけ注目してタグを削除する方法では<FONT COLOR="Red">うまくいかない</FONT>場合があります．<BLOCKQUOTE><PRE># $str の中のタグを削除した $result を作る(不完全)($result = $str) =~ s/&lt;[^&gt;]*&gt;//g;</PRE></BLOCKQUOTE><P>具体的には次のような不具合があります．<UL>  <LI><NOBR><TT>&lt;!-- &lt;FOO&gt; --&gt;</TT></NOBR>    のようなコメントの <NOBR><TT>&lt;!-- &lt;FOO&gt;</TT></NOBR>    を削除してしまう．  <LI><NOBR><TT>&lt;FOO BAR=&quot;&gt;&quot;&gt;</TT></NOBR>    のようにダブルクォートで囲んだ中に <TT>&gt;</TT>    があると，そこをタグの終了と間違って    <NOBR><TT>&lt;FOO BAR=&quot;&gt;</TT></NOBR> を削除してしまう．  <LI><NOBR><TT>&lt;XMP&gt;&lt;FOO&gt;&lt;/XMP&gt;</TT></NOBR> のように    <NOBR>XMPタグ</NOBR>や <NOBR>PLAINTEXTタグ</NOBR>，    <NOBR>SCRIPTタグ</NOBR>の中の一見タグに見える    <NOBR><TT>&lt;FOO&gt;</TT></NOBR> も削除してしまう．</UL><P>最初のスクリプトではこのような場合にもうまくいくようになっています．ただし，<NOBR>HTML文書</NOBR>として正しく書かれている場合を想定していますので，&lt; に対応する &gt; がないときなどは予期せぬ動作をすることになります．<P>もし <NOBR>BRタグ</NOBR>や <NOBR>Aタグ</NOBR>など特定のタグだけは削除したくない場合には， <NOBR><CODE>$tag_tmp = $2;</CODE></NOBR> の後に，次のようにして <NOBR><CODE>$tag_tmp</CODE></NOBR> を<NOBR><CODE>$result</CODE></NOBR> に加えるようにすればできます．<BLOCKQUOTE><B><PRE>  $result .= $tag_tmp if $tag_tmp =~ /^&lt;\/?(BR|A)(?![0-9A-Za-z])/i;</PRE></B></BLOCKQUOTE><P>逆に <NOBR>FONTタグ</NOBR>や <NOBR>IMGタグ</NOBR>など特定のタグだけ削除したい場合には， <NOBR><CODE>$tag_tmp = $2;</CODE></NOBR> の後に，次のようにして <NOBR><CODE>$tag_tmp</CODE></NOBR> を<NOBR><CODE>$result</CODE></NOBR> に加えるようにすればできます．<BLOCKQUOTE><B><PRE>  $result .= $tag_tmp if $tag_tmp !~ /^&lt;\/?(FONT|IMG)(?![0-9A-Za-z])/i;</PRE></B></BLOCKQUOTE><P><A HREF="http://search.cpan.org/search?dist=HTML-Parser"><NOBR>モジュール <CODE>HTML::TokeParser</CODE></NOBR></A> の<NOBR><CODE>get_text</CODE> メソッド</NOBR>，または<NOBR><CODE>get_trimmed_text</CODE>メソッド</NOBR>や，<A HREF="http://www.perl.com/CPAN/authors/Tom_Christiansen/scripts/striphtml.gz">striphtml</A>を使っても同じようなことができます．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="AutoLink"><HR></A><H2>自動で URI(URL) のリンクを張る</H2><BLOCKQUOTE><P><NOBR><CODE>$str</CODE></NOBR> は<FONT COLOR="Blue"><NOBR>EUC-JP</NOBR> という前提</FONT>ですので，必要ならばあらかじめ <NOBR>EUC-JP</NOBR> に変換しておいてください．漢字コードの変換に関しては「<A HREF="#JP_Trans">漢字コードを <NOBR>EUC-JP</NOBR>に変換して処理する</A>」を参照．<BLOCKQUOTE><B><PRE># $str の中の URI(URL) にリンクを張った $result を作る# $tag_regex と $tag_regex_ は別途参照# $http_URL_regex と $ftp_URL_regex および $mail_regex は別途参照$text_regex = q{[^&lt;]*};$result = '';  $skip = 0;while ($str =~ /($text_regex)($tag_regex)?/gso) {  last if $1 eq '' and $2 eq '';  $text_tmp = $1;  $tag_tmp = $2;  if ($skip) {    $result .= $text_tmp . $tag_tmp;    $skip = 0 if $tag_tmp =~ /^&lt;\/[aA](?![0-9A-Za-z])/;  } else {    $text_tmp =~ s{($http_URL_regex|$ftp_URL_regex|($mail_regex))}      {my($org, $mail) = ($1, $2);       (my $tmp = $org) =~ s/"/&amp;quot;/g;       '&lt;A HREF="' . ($mail ne '' ? 'mailto:' : '') . &quot;$tmp\&quot;&gt;$org&lt;/A&gt;&quot;}ego;    $result .= $text_tmp . $tag_tmp;    $skip = 1 if $tag_tmp =~ /^&lt;[aA](?![0-9A-Za-z])/;    if ($tag_tmp =~ /^&lt;(XMP|PLAINTEXT|SCRIPT)(?![0-9A-Za-z])/i) {      $str =~ /(.*?(?:&lt;\/$1(?![0-9A-Za-z])$tag_regex_|$))/gsi;      $result .= $1;    }  }}</PRE></B></BLOCKQUOTE><P><NOBR><CODE>$http_URL_regex</CODE></NOBR> については「<A HREF="#httpURL"><NOBR>http URL</NOBR> の正規表現</A>」，<NOBR><CODE>$ftp_URL_regex</CODE></NOBR> については「<A HREF="#ftpURL"><NOBR>ftp URL</NOBR> の正規表現</A>」，<NOBR><CODE>$mail_regex</CODE></NOBR>については「<A HREF="#Mail">メールアドレスの正規表現</A>」の最後に書いてあるスクリプトを正規表現として使います．また， <NOBR><CODE>$tag_regex</CODE></NOBR>および <NOBR><CODE>$tag_regex_</CODE></NOBR> については「<A HREF="#HTML_Tag"><NOBR>HTMLタグ</NOBR>の正規表現</A>」のスクリプトを正規表現として使います．また， <NOBR><CODE>$str</CODE></NOBR> には<FONT COLOR="Red"><NOBR>HTML文書</NOBR>全体</FONT>を入れておきます．このスクリプトは以下の項目に当てはまらない <NOBR>http URL</NOBR> と <NOBR>ftp URL</NOBR>およびメールアドレスについてリンクを張ります．<UL>  <LI>タグ(コメント)の内部である．  <LI><NOBR>Aタグ</NOBR>でリンクが張ってある．  <LI><NOBR>XMPタグ</NOBR>，<NOBR>PLAINTEXTタグ</NOBR>，    <NOBR>SCRIPTタグ</NOBR>の有効範囲内である．</UL><P>このスクリプトの説明を簡単にします． <NOBR><CODE>$str</CODE></NOBR>に対して，テキスト部分とタグ部分をそれぞれ <NOBR>1つ</NOBR>ずつ探して<NOBR><CODE>while</CODE> 文</NOBR> をまわします．タグ部分は特に処理する必要はないのでそのままです． <NOBR><CODE>$skip</CODE></NOBR>は <NOBR>Aタグ</NOBR>でリンクを張り始めたときに 1 になります．このときはテキスト部分を特に処理することなくそのままにします．<NOBR>Aタグ</NOBR>が閉じたときに <NOBR><CODE>$skip</CODE></NOBR> を 0 に戻します．<NOBR>Aタグ</NOBR>でリンクを張っていないとき，テキスト部分に<NOBR>http URL</NOBR> か <NOBR>ftp URL</NOBR> またはメールアドレスを見つけた場合にはリンクを張ります．<P>もし，タグ部分が <NOBR>XMPタグ</NOBR>，または，<NOBR>PLAINTEXTタグ</NOBR>だった場合には，次に対応する閉じタグまで無条件にスキップします．無条件というのは，<NOBR><CODE>while</CODE>文</NOBR>にある条件でテキスト部分とタグ部分を取り出すことができなくなるため，閉じタグだけに注目するということです．なぜなら，これらのタグの有効範囲内では他の<FONT COLOR="Blue">タグが無効</FONT>になり，そのまま表示されるからです．逆に言えば，これらのタグの有効範囲内ではタグに見えてもタグではなく，普通のテキストと同じように扱わなくてはならないということです．ただし，この部分に <NOBR>http URL</NOBR> や<NOBR>ftp URL</NOBR>，メールアドレスがある場合でもリンクは張りません．もし張ったとしても，それはそのまま表示されてしまい意味がないからです．<NOBR>SCRIPTタグ</NOBR>についても同様です．<P><NOBR><CODE>$str</CODE></NOBR> に対するパターンマッチが行なわれている<NOBR>2ヶ所</NOBR>ともに<FONT COLOR="Red"><NOBR>修飾子 <CODE>g</CODE></NOBR></FONT>がつけられていることに注目してください．<NOBR>修飾子 <CODE>g</CODE></NOBR>をつけたパターンマッチを<FONT COLOR="Red">スカラーコンテキスト</FONT>で行なうと，前回どこまでパターンマッチを行なったかを保存しておいて，次回その続きから検索を始めてくれます．このスクリプトでは基本的にテキスト部分とタグ部分を <NOBR>1つ</NOBR>ずつ探して <NOBR><CODE>while</CODE>文</NOBR>をまわしているのですが，<NOBR>XMPタグ</NOBR>，<NOBR>PLAINTEXTタグ</NOBR>，<NOBR>SCRIPTタグ</NOBR>のときだけは別処理をする必要があります．その処理終了後 <NOBR><CODE>while</CODE>文</NOBR>に戻ったときには，その続きからパターンマッチをしてもらう必要があります． このようなときに，<NOBR><CODE>$str</CODE></NOBR> に対するどちらのパターンマッチにおいても<NOBR>修飾子 <CODE>g</CODE></NOBR> がつけられていますので，どちらの場合も都合よく続きからパターンマッチを始めることができるわけです．<P>置換によってリンクを張る処理ですが，単純に次のように行なったのでは<NOBR>2つ</NOBR>の理由からまずいことになります．<BLOCKQUOTE><PRE>    $text_tmp =~ s/($http_URL_regex)/&lt;A HREF=&quot;$1&quot;&gt;$1&lt;\/A&gt;/go;    $text_tmp =~ s/($ftp_URL_regex)/&lt;A HREF=&quot;$1&quot;&gt;$1&lt;\/A&gt;/go;    $text_tmp =~ s/($mail_regex)/&lt;A HREF=&quot;mailto:$1&quot;&gt;$1&lt;\/A&gt;/go;</PRE></BLOCKQUOTE><P><NOBR>1つ</NOBR>目の理由は，タグの中ではダブルクォートで囲む都合上，マッチしたものがダブルクォートを含んでいるとまずいことになるということです．そこで，ダブルクォートで囲む部分については，マッチしたものに含まれるダブルクォートを <NOBR><TT>&amp;quot;</TT></NOBR> に変換するという処理が必要になります．<P><NOBR>2つ</NOBR>目の理由ですが，置換の処理が <NOBR>http URL</NOBR>，<NOBR>ftp URL</NOBR>，メールアドレスのそれぞれについて独立して行なわれているということです．これらは互いに他の正規表現にマッチする部分を含むことができます．具体的な例で言いますと，次のようなものが挙げられます．<BLOCKQUOTE><PRE>http://www.din.or.jp/~ohzaki/?ftp://ftp.din.or.jp/+ohzaki@din.or.jpftp://ftp.din.or.jp/ohzaki@din.or.jp"http://www.din.or.jp/~ohzaki/?ftp://ftp.din.or.jp/"@din.or.jp</PRE></BLOCKQUOTE><P>上から順に <NOBR>http URL</NOBR>，<NOBR>ftp URL</NOBR>，メールアドレスとなっています．これらを独立して置換処理した場合，メールアドレスの一部を<NOBR>http URL</NOBR> として置換してしまったり，<NOBR>http URL</NOBR>の一部を <NOBR>ftp URL</NOBR> として置換してしまうというようなことが起こってしまいます．どちらがどちらに含まれるのかわからないので，置換処理の順番でどうこうできる問題ではありません．幸いなことに，先頭部分が他の正規表現にマッチすることはありませんので，これらの置換処理を<NOBR>1つ</NOBR>の正規表現としてまとめて，<NOBR>1回</NOBR>の置換処理で行なうことにより，うまくリンクを張ることができます．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="Character"><HR></A><H2>文字の正規表現</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># 半角スペース$space = '\x20';# 全角スペース$Zspace = '(?:\xA1\xA1)'; # EUC-JP$Zspace_sjis = '(?:\x81\x40)'; # SJIS# 全角数字 [０-９]$Zdigit = '(?:\xA3[\xB0-\xB9])'; # EUC-JP$Zdigit_sjis = '(?:\x82[\x4F-\x58])'; # SJIS# 全角大文字 [Ａ-Ｚ]$Zuletter = '(?:\xA3[\xC1-\xDA])'; # EUC-JP$Zuletter_sjis = '(?:\x82[\x60-\x79])'; # SJIS# 全角小文字 [ａ-ｚ]$Zlletter = '(?:\xA3[\xE1-\xFA])'; # EUC-JP$Zlletter_sjis = '(?:\x82[\x81-\x9A])'; # SJIS# 全角アルファベット [Ａ-Ｚａ-ｚ]$Zalphabet = '(?:\xA3[\xC1-\xDA\xE1-\xFA])'; # EUC-JP$Zalphabet_sjis = '(?:\x82[\x60-\x79\x81-\x9A])'; # SJIS# 全角ひらがな [ぁ-ん]$Zhiragana = '(?:\xA4[\xA1-\xF3])'; # EUC-JP$Zhiragana_sjis = '(?:\x82[\x9F-\xF1])'; # SJIS# 全角ひらがな(拡張) [ぁ-ん゛゜ゝゞ]$ZhiraganaExt = '(?:\xA4[\xA1-\xF3]|\xA1[\xAB\xAC\xB5\xB6])'; # EUC-JP$ZhiraganaExt_sjis = '(?:\x82[\x9F-\xF1]|\x81[\x4A\x4B\x54\x55])'; # SJIS# 全角カタカナ [ァ-ヶ]$Zkatakana = '(?:\xA5[\xA1-\xF6])'; # EUC-JP$Zkatakana_sjis = '(?:\x83[\x40-\x96])'; # SJIS# 全角カタカナ(拡張) [ァ-ヶ・ーヽヾ]$ZkatakanaExt = '(?:\xA5[\xA1-\xF6]|\xA1[\xA6\xBC\xB3\xB4])'; # EUC-JP$ZkatakanaExt_sjis = '(?:\x83[\x40-\x96]|\x81[\x45\x5B\x52\x53])'; # SJIS# 半角カタカナ [ヲ-゜]$Hkatakana = '(?:\x8E[\xA6-\xDF])'; # EUC-JP$Hkatakana_sjis = '[\xA6-\xDF]'; # SJIS# EUC-JP文字$ascii = '[\x00-\x7F]'; # 1バイト EUC-JP文字$twoBytes = '(?:[\x8E\xA1-\xFE][\xA1-\xFE])'; # 2バイト EUC-JP文字$threeBytes = '(?:\x8F[\xA1-\xFE][\xA1-\xFE])'; # 3バイト EUC-JP文字$character = &quot;(?:$ascii|$twoBytes|$threeBytes)&quot;; # EUC-JP文字# EUC-JP文字(機種依存文字・未定義領域・3バイト文字を含まない)$character_strict = '(?:[\x00-\x7F]|' # ASCII  . '\x8E[\xA1-\xDF]|' # 半角カタカナ  . '[\xA1\xB0-\xCE\xD0-\xF3][\xA1-\xFE]|' # 1,16-46,48-83区  . '\xA2[\xA1-\xAE\xBA-\xC1\xCA-\xD0\xDC-\xEA\xF2-\xF9\xFE]|' # 2区  . '\xA3[\xB0-\xB9\xC1-\xDA\xE1-\xFA]|' # 3区  . '\xA4[\xA1-\xF3]|' # 4区  . '\xA5[\xA1-\xF6]|' # 5区  . '\xA6[\xA1-\xB8\xC1-\xD8]|' # 6区  . '\xA7[\xA1-\xC1\xD1-\xF1]|' # 7区  . '\xA8[\xA1-\xC0]|' # 8区  . '\xCF[\xA1-\xD3]|' # 47区  . '\xF4[\xA1-\xA6])'; # 84区# EUC-JP未定義文字(機種依存文字・3バイト文字を含む)$character_undef = '(?:[\xA9-\xAF\xF5-\xFE][\xA1-\xFE]|' # 9-15,85-94区  . '\x8E[\xE0-\xFE]|' # 半角カタカナ  . '\xA2[\xAF-\xB9\xC2-\xC9\xD1-\xDB\xEB-\xF1\xFA-\xFD]|' # 2区  . '\xA3[\XA1-\xAF\xBA-\xC0\xDB-\xE0\xFB-\xFE]|' # 3区  . '\xA4[\xF4-\xFE]|' # 4区  . '\xA5[\xF7-\xFE]|' # 5区  . '\xA6[\x89-\xC0\xD9-\xFE]|' # 6区  . '\xA7[\xC2-\xD0\xF2-\xFE]|' # 7区  . '\xA8[\xC1-\xFE]|' # 8区  . '\xCF[\xD4-\xFE]|' # 47区  . '\xF4[\xA7-\xFE]|' # 84区  . '\x8F[\xA1-\xFE][\xA1-\xFE])'; # 3バイト文字# SJIS文字$oneByte_sjis = '[\x00-\x7F\xA1-\xDF]'; # 1バイト SJIS文字$twoBytes_sjis =  '(?:[\x81-\x9F\xE0-\xFC][\x40-\x7E\x80-\xFC])'; # 2バイト SJIS文字$character_sjis = &quot;(?:$oneByte_sjis|$twoBytes_sjis)&quot;; # SJIS文字# SJIS文字(機種依存文字・未定義領域を含まない)$character_sjis_strict = '(?:[\x00-\x7F\xA1-\xDF]|' # ASCII，半角カタカナ  . '[\x89-\x97\x99-\x9F\xE0-\xE9][\x40-\x7E\x80-\xFC]|' # 17-46,49-82区  . '\x81[\x40-\x7E\x80-\xAC\xB8-\xBF\xC8-\xCE\xDA-\xE8\xF0-\xF7\xFC]|' # 1,2区  . '\x82[\x4F-\x58\x60-\x79\x81-\x9A\x9F-\xF1]|' # 3,4区  . '\x83[\x40-\x7E\x80-\x96\x9F-\xB6\xBF-\xD6]|' # 5,6区  . '\x84[\x40-\x60\x70-\x7E\x80-\x91\x9F-\xBE]|' # 7,8区  . '\x88[\x9F-\xFC]|' # 15,16区  . '\x98[\x40-\x72\x9F-\xFC]|' # 47,48区  . '\xEA[\x40-\x7E\x80-\xA4])'; # 83,84区# SJIS未定義文字(機種依存文字を含む)$character_sjis_undef =  '(?:[\x85-\x87\xEB-\xFC][\x40-\x7E\x80-\xFC]|' # 9-14,85-120区  . '\x81[\xAD-\xB7\xC0-\xC7\xCF-\xD9\xE9-\xEF\xF8-\xFB]|' # 1,2区  . '\x82[\x40-\x4E\x59-\x5F\x7A-\x7E\x80\x9B-\x9E\xF2-\xFC]|' # 3,4区  . '\x83[\x97-\x9E\xB7-\xBE\xD7-\xFC]|' # 5,6区  . '\x84[\x61-\x6F\x92-\x9E\xBF-\xFC]|' # 7,8区  . '\x88[\x40-\x7E\x80-\x9E]|' # 15,16区  . '\x98[\x73-\x7E\x80-\x9E]|' # 47,48区  . '\xEA[\xA5-\xFC])'; # 83,84区# iモード対応絵文字(おまけ)$iHieroglyph = '(?:\xF8[\x9F-\xFC]|\xF9[\x40-\x7E\x80-\xAF])'; # SJIS</PRE></B></BLOCKQUOTE><P>日本語の扱いについては「<A HREF="#JP">日本語を扱う</A>」を参照．<P>個々の機種依存文字についてはここでは扱わないこととする．なぜなら，機種依存文字は各ベンダ・文字コードごとに非常に多くの種類が存在し，そのすべてを把握することは不可能なためである．以下のリンク先の文書の外字(ユーザ定義とベンダ定義)の欄が機種依存文字に該当する．<UL>  <LI><A HREF="http://www.opengroup.or.jp/jvc/cde/euc.html">  ベンダ別 EUC コード一覧</A>  <LI><A HREF="http://www.opengroup.or.jp/jvc/cde/sjis.html">  ベンダ別 SJIS コード一覧</A></UL></BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="HTML_Tag"><HR></A><H2><NOBR>HTMLタグ</NOBR>の正規表現</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># HTMLタグの正規表現 $tag_regex$tag_regex_ = q{[^&quot;'&lt;&gt;]*(?:&quot;[^&quot;]*&quot;[^&quot;'&lt;&gt;]*|'[^']*'[^&quot;'&lt;&gt;]*)*(?:&gt;|(?=&lt;)|$(?!\n))}; #'}}}}$comment_tag_regex =    '&lt;!(?:--[^-]*-(?:[^-]+-)*?-(?:[^&gt;-]*(?:-[^&gt;-]+)*?)??)*(?:&gt;|$(?!\n)|--.*$)';$tag_regex = qq{$comment_tag_regex|&lt;$tag_regex_};</PRE></B></BLOCKQUOTE><P>このスクリプトの <NOBR><CODE>$comment_tag_regex</CODE></NOBR>がコメントタグの正規表現で，<NOBR><CODE>$tag_regex_</CODE></NOBR> がコメントタグ以外の普通のタグの &lt; 以降の正規表現になります．<P>最初に普通のタグの正規表現について説明します．普通のタグの中身の正規表現として最初に思いつくのは <NOBR><CODE>[^&gt;]*</CODE></NOBR> です．しかし，これではダブルクォートやシングルクォートで囲まれた中に<CODE>&gt;</CODE> があった場合にまずいことになります．そこで，ダブルクォートやシングルクォートについて考えます．<P>ダブルクォートで囲まれている部分の正規表現は<NOBR><CODE>&quot;[^&quot;]*&quot;</CODE></NOBR> と書くことができます．シングルクォートで囲まれている部分についても同様です．これでダブルクォートやシングルクォートで囲まれている内側には <CODE>&gt;</CODE>を含むことができます．それ以外のダブルクォートでもシングルクォートでも囲まれていない部分は今度こそ <NOBR><CODE>[^&gt;]</CODE></NOBR> だから，結局<NOBR><CODE>(?:[^&gt;]|&quot;[^&quot;]*&quot;|'[^']')*</CODE></NOBR>でいいか，というとそううまくはいきません．<NOBR><CODE>[^&gt;]</CODE></NOBR> ではダブルクォートやシングルクォートまで含んでしまうため，せっかく用意したダブルクォートやシングルクォートで囲まれている部分の正規表現が使われることなくそのままマッチングが進んで，ダブルクォートやシングルクォートの中の <CODE>&gt;</CODE> をタグの終わりと間違えてマッチが成功してしまいます．<P>これを回避するには，<NOBR><CODE>(?:&quot;[^&quot;]*&quot;|'[^']*'|[^&gt;])*</CODE></NOBR>のように最初にダブルクォートかシングルクォートで囲まれているかどうかを調べる方法があります．しかし，これは明らかに<FONT COLOR="Red">遅い</FONT>です．なぜかというと，ダブルクォートやシングルクォートで囲まれていない部分の場合，<NOBR>1文字</NOBR>ごとにダブルクォートとシングルクォートのマッチングが失敗してからでないと <NOBR><CODE>[^&gt;]</CODE></NOBR> にマッチしないためです．そこで次のように<NOBR><CODE>[^&quot;'&gt;]</CODE></NOBR> とするとすべてがうまくいきます．<BLOCKQUOTE><PRE>$tag_regex_ = q{(?:[^&quot;'&gt;]|&quot;[^&quot;]*&quot;|'[^']*')*}; #'}}}</PRE></BLOCKQUOTE><P>次に閉じないタグのことを考えます．閉じないタグとは<NOBR><CODE>&lt;P&lt;B&gt;</CODE></NOBR> のように <CODE>&gt;</CODE>を省略してあるものです．このとき <NOBR><CODE>&lt;P</CODE></NOBR>を正しくタグとして認識するためには，タグの中身は<NOBR><CODE>[^&gt;]*</CODE></NOBR> ではなく<NOBR><CODE>[^&lt;&gt;]*</CODE></NOBR> としなければならないことになります．また，タグの最後は必ず <CODE>&gt;</CODE> で終わるとは限らないので，<NOBR><CODE>(?:&gt;|(?=&lt;)|$(?!\n))</CODE></NOBR> とする必要があります．これは <CODE>&gt;</CODE> で終わる普通のタグか，または，その次の文字がタグの開始文字である <CODE>&lt;</CODE> であるか，または，文字列の最後である場合を表しています．<NOBR><CODE>$(?!\n)</CODE></NOBR>については後で詳しく説明します．結局，これをまとめると次のようになります．<BLOCKQUOTE><PRE>$tag_regex_ = q{(?:[^&quot;'&lt;&gt;]|&quot;[^&quot;]*&quot;|'[^']*')*(?:&gt;|(?=&lt;)|$(?!\n))}; #'}}}</PRE></BLOCKQUOTE><P>これを <NOBR>Jeffrey E. F. Friedl</NOBR>氏原著による「<A HREF="http://www.oreilly.co.jp/BOOK/regex.htm">詳説 正規表現</A>(<A HREF="http://www.oreilly.com/catalog/regex/">Mastering Regular Expressions </A>)」で「<FONT COLOR="Blue">ループ展開</FONT>」として書かれている手法で<FONT COLOR="Red">実行速度を速く</FONT>したものが最初のスクリプトの正規表現です．簡単なベンチマークをとってみたところ<NOBR>約 1.5倍</NOBR>ほど速かったです．<P>次にコメントタグの正規表現の説明をします．コメントタグについては，まずは水無月 ばけらさんによる「<A HREF="http://www.ne.jp/asahi/minazuki/bakera/html/sgml/comdeclare">SGMLの注釈宣言</A>」を一読することをお勧めします．<P>コメントタグ，すなわち，注釈宣言は <NOBR><TT>--コメントの中身--</TT></NOBR>というコメントだけから構成されています．コメントタグは<FONT COLOR="Red">複数のコメントを持つ</FONT>ことができ，コメントの後ろには<FONT COLOR="Red">空白文字のみ</FONT>あってもかまいません．また，コメントの中身やコメントの数が <NOBR>0個</NOBR>であってもかまいません．ただし，<NOBR><TT>&lt;!</TT></NOBR> とコメントの間に空白文字があることは許されていないので，<NOBR><TT>&lt;!</TT></NOBR> の直後にはコメントか閉じ括弧の <TT>&gt;</TT> しか来てはいけないことになります．以上のことから，正常なコメントタグの正規表現は次のようになります．<BLOCKQUOTE><B><PRE># 正常なコメントタグの正規表現 $comment_tag_regex$comment_tag_regex = q{&lt;!(?:--(?:(?!--).)*--\s*)*&gt;};</PRE></B></BLOCKQUOTE><P>この正常なコメントタグの正規表現をもとに，閉じないコメントタグだった場合と，コメントの後ろに空白文字以外の文字があって不正であるコメントタグだった場合にも対応した正規表現が最初のスクリプトになります．<P>最後の <NOBR><CODE>(?:&gt;|$(?!\n)|--.*$)</CODE></NOBR> の選択はそれぞれ，コメントタグが閉じていた場合，コメントの後に <CODE>&gt;</CODE> がなく閉じていなかった場合，コメントの終わりの <NOBR><CODE>--</CODE></NOBR>がなくコメントの中身が最後まで続いている場合を表わしています．<NOBR><CODE>$(?!\n)</CODE></NOBR>ですが，ただの <CODE>$</CODE> でもよいのではないかと疑問に思われる人もいるかと思いますが，<NOBR><CODE>$(?!\n)</CODE></NOBR> と <CODE>$</CODE> では少し<FONT COLOR="Red">意味が違います</FONT>．たとえば，<NOBR><CODE>$str = &quot;test\n&quot;;</CODE></NOBR> のとき，<NOBR><CODE>m/^test$/</CODE></NOBR>はマッチしますが，<NOBR><CODE>m/^test$(?!\n)/</CODE></NOBR> はマッチしません．なぜなら，<CODE>$</CODE> は文字列の最後に改行があった場合には，<FONT COLOR="Red">改行の直前でもマッチする</FONT>からです．もし，<NOBR><CODE>'test'</CODE></NOBR> にはマッチしてほしいが，<NOBR><CODE>&quot;test\n&quot;</CODE></NOBR>にはマッチしてほしくないというときに，ただの<CODE>$</CODE> では困るわけです．コメントタグの正規表現では<NOBR><CODE>&quot;&lt;!\n&quot;</CODE></NOBR>のような場合にマッチしてもらっては困るのでこのような正規表現になっています．<NOBR>perl5.005</NOBR> 以降ならば<NOBR><CODE>$(?!\n)</CODE></NOBR> を <NOBR><CODE>\z</CODE></NOBR>とすることができます．<NOBR><CODE>\z</CODE></NOBR> は <CODE>$</CODE> や <NOBR><CODE>\Z</CODE></NOBR>と違って本当の意味で文字列の最後にマッチします．<P>実は次のようにコメントタグの正規表現を書いても同じことができます．理解するにはまずこちらの正規表現をもとに考えた方がよいかもしれません．<BLOCKQUOTE><PRE># コメントタグの正規表現(遅い)$comment_tag_regex = '&lt;!(?:--(?:(?!--).)*--(?:(?!--)[^>])*)*(?:&gt;|$(?!\n)|--.*$)';</PRE></BLOCKQUOTE><P>この正規表現では，コメントの中身を表わす正規表現として<NOBR><CODE>(?:(?!--).)*</CODE></NOBR> としています．これの意味は，次に<NOBR><CODE>--</CODE></NOBR>が来ないような何か <NOBR>1文字</NOBR>の繰り返しということです．つまり，<CODE>-</CODE> が単独で現れた場合には問題ないわけで，<NOBR><CODE>--</CODE></NOBR> と続けて現れる <CODE>-</CODE>は駄目だということになります．これでコメントの中身には <NOBR><CODE>--</CODE></NOBR> が絶対に現れないことが保証されます．コメントの中身を表わす正規表現としてはこれで正しいのですが，<NOBR>1文字</NOBR>ごとに <NOBR><CODE>--</CODE></NOBR> でないことをチェックしているのでこのままでは<FONT COLOR="Red">実行速度が遅い</FONT>です．<P>そこで普通のタグのときと同様に「<FONT COLOR="Blue">ループ展開</FONT>」の手法を用いることとします．まず，<NOBR><CODE>--</CODE></NOBR> が来ない何か<NOBR>1文字</NOBR>の繰り返しを表わす <NOBR><CODE>(?:(?!--).)*</CODE></NOBR>を少し違う考え方で表現し直します．この正規表現は <NOBR><CODE>--</CODE></NOBR>が含まれない部分ということですので，まず，<CODE>-</CODE>以外の文字ならば問題ないことはすぐにわかると思います．仮に<CODE>-</CODE> が来たとしてもその次の文字が<CODE>-</CODE>以外の文字であればその場合もまた大丈夫です．ということは，<NOBR><CODE>(?:(?!--).)*</CODE></NOBR> は<NOBR><CODE>(?:[^-]|-[^-])*</CODE></NOBR> と変形することができます．これに対して「<FONT COLOR="Blue">ループ展開</FONT>」の手法を用いると，<NOBR><CODE>[^-]*(?:-[^-][^-]*)*</CODE></NOBR> となり，結局<NOBR><CODE>[^-]*(?:-[^-]+)*</CODE></NOBR> となります．<P>これでコメント部分の正規表現は<NOBR><CODE>--[^-]*(?:-[^-]+)*--</CODE></NOBR> となりました．簡単なベンチマークをとったところ<FONT COLOR="Red">約 <NOBR>2倍</NOBR>ほど速くなりました</FONT>．しかし，まだ最初のスクリプトとは少し違っています．このコメント部分の正規表現には<FONT COLOR="Blue">非決定性</FONT>なところがあります．それは <CODE>-</CODE> が来たときに，その時点ではそれがコメントの中身なのか，コメントの終了を表わす<NOBR><CODE>--</CODE></NOBR> の最初の <NOBR>1文字</NOBR>なのかわかりませんが，正規表現でもやはりマッチする可能性がある場所が <NOBR>2ヶ所</NOBR>になっているということです．つまり，<NOBR><CODE>(?:-[^-]+)*</CODE></NOBR> の<NOBR><CODE>(?:</CODE></NOBR> 直後の <CODE>-</CODE>にマッチするかもしれないし，<NOBR><CODE>(?:-[^-]+)*</CODE></NOBR> 直後の <CODE>-</CODE>にマッチするかもしれないのです．このような非決定性はバックトラック発生時に多くの負担を強いることになります．そこで，<NOBR><CODE>[^-]*(?:-[^-]+)*--</CODE></NOBR> を変形し，非決定性を排除すると<NOBR><CODE>[^-]*-(?:[^-]+-)*-</CODE></NOBR> となります．これで<CODE>-</CODE> が来たときにマッチする正規表現の部分は<NOBR><CODE>[^-]*</CODE></NOBR> 直後の <CODE>-</CODE> の <NOBR>1ヶ所</NOBR>となります．<P>ここまでの変形でかなり最初のスクリプトに近づきましたが，まだ<NOBR>1ヶ所</NOBR>違っています．それは <NOBR><CODE>(?:[^-]+-)*</CODE></NOBR>と <NOBR><CODE>(?:[^-]+-)*?</CODE></NOBR>，つまり，<CODE>*</CODE> と <NOBR><CODE>*?</CODE></NOBR> の違いです．一般に<CODE>*</CODE> と <NOBR><CODE>*?</CODE></NOBR> を変えたらマッチするものも変わってしまいます．しかし，今回の場合は <CODE>*</CODE> でも<NOBR><CODE>*?</CODE></NOBR> でも必ず同じ結果となります．必ず同じ結果となることがわかっているので，実行速度が速い方を考えます．一般にコメントタグというものは<NOBR><TT>&lt;-- これはコメントタグです --&gt;</TT></NOBR> というようなものがほとんどでしょう．つまり，コメントタグの中身として <CODE>-</CODE>を含んでいるものの出現頻度は，含んでいないものの出現頻度よりも低いということです．もし，コメントタグの中身に <CODE>-</CODE> を含んでいた場合は <NOBR><CODE>(?:[^-]+-)</CODE></NOBR> の部分を通過することになります．しかし，実際には含んでいないことの方が多いわけですから，<NOBR><CODE>(?:[^-]+-)</CODE></NOBR> の部分をチェックするのは無駄なことになります．そこで，<CODE>*</CODE> を <NOBR><CODE>*?</CODE></NOBR> とすることでこの無駄を可能な限り排除することができます．<P>次に <NOBR><CODE>(?:(?!--)[^>])*</CODE></NOBR> の部分について考えます．ここもコメントタグの中身の部分と同様にまずは「<FONT COLOR="Blue">ループ展開</FONT>」の手法を用いて<NOBR><CODE>(?:[^&gt;-]*(?:-[^&gt;-]+)*</CODE></NOBR> と変形します．更に，<CODE>*</CODE> を <NOBR><CODE>*?</CODE></NOBR> とすることができますので，<NOBR><CODE>(?:[^&gt;-]*(?:-[^&gt;-]+)*?</CODE></NOBR>と変形するところまでは同じです．<P>最初のスクリプトでは更に全体を <NOBR><CODE>(?: regex)??</CODE></NOBR>というように <NOBR><CODE>??</CODE></NOBR> をつけた形にしています．これは，コメントタグの中身と違って，一般にコメントの終了を表わす<NOBR><CODE>--</CODE></NOBR> の後ろには何か文字が入ることなく直後に&gt; で閉じられているものの出現頻度が高いと思われるためです．言い換えると，<NOBR><CODE>(?:[^&gt;-]*(?:-[^&gt;-]+)*?</CODE></NOBR>がマッチすることはほとんどない，つまり，マッチさせようとすると無駄に終わることが多いと思われるため，この部分の正規表現全体に<NOBR><CODE>??</CODE></NOBR> をつけて，可能な限りチェックさせないようにしています．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="URI"><HR></A><H2>URI(URL) の正規表現</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># $uri が正しい URI か判定する$digit = q{[0-9]};$upalpha = q{[A-Z]};$lowalpha = q{[a-z]};$alpha = qq{(?:$lowalpha|$upalpha)};$alphanum = qq{(?:$alpha|$digit)};$hex = qq{(?:$digit|[A-Fa-f])};$escaped = qq{%$hex$hex};$mark = q{[-_.!~*'()]};$unreserved = qq{(?:$alphanum|$mark)};$reserved = q{[;/?:@&amp;=+$,]};$uric = qq{(?:$reserved|$unreserved|$escaped)};$fragment = qq{$uric*};$query = qq{$uric*};$pchar = qq{(?:$unreserved|$escaped|} . q{[:@&amp;=+$,])};$param = qq{$pchar*};$segment = qq{$pchar*(?:;$param)*};$path_segments = qq{$segment(?:/$segment)*};$abs_path = qq{/$path_segments};$uric_no_slash = qq{(?:$unreserved|$escaped|} . q{[;?:@&amp;=+$,])};$opaque_part = qq{$uric_no_slash$uric*};$path = qq{(?:$abs_path|$opaque_part)?};$port = qq{$digit*};$IPv4address = qq{$digit+\\.$digit+\\.$digit+\\.$digit+};$toplabel = qq{(?:$alpha|$alpha(?:$alphanum|-)*$alphanum)};$domainlabel = qq{(?:$alphanum|$alphanum(?:$alphanum|-)*$alphanum)};$hostname = qq{(?:$domainlabel\\.)*$toplabel\\.?};$host = qq{(?:$hostname|$IPv4address)};$hostport = qq{$host(?::$port)?};$userinfo = qq{(?:$unreserved|$escaped|} . q{[;:&amp;=+$,])*};$server = qq{(?:(?:$userinfo\@)?$hostport)?};$reg_name = qq{(?:$unreserved|$escaped|} . q{[$,;:@&amp;=+])+};$authority = qq{(?:$server|$reg_name)};$scheme = qq{$alpha(?:$alpha|$digit|[-+.])*};$rel_segment = qq{(?:$unreserved|$escaped|} . q{[;@&amp;=+$,])+};$rel_path = qq{$rel_segment(?:$abs_path)?};$net_path = qq{//$authority(?:$abs_path)?};$hier_part = qq{(?:$net_path|$abs_path)(?:\\?$query)?};$relativeURI = qq{(?:$net_path|$abs_path|$rel_path)(?:\\?$query)?};$absoluteURI = qq{$scheme:(?:$hier_part|$opaque_part)};$URI_reference = qq{(?:$absoluteURI|$relativeURI)?(?:#$fragment)?};$pattern = $URI_reference;print &quot;ok\n&quot; if $uri =~ /^$pattern$/o;</PRE></B></BLOCKQUOTE><P>URI については<A HREF="http://www.csl.sony.co.jp/cgi-bin/hyperrfc?2396"><NOBR>RFC 2396</NOBR></A>(<A HREF="http://member.nifty.ne.jp/moha/rfc/rfc2396j.txt">日本語訳</A> )に書かれています．それを機械的に素直に正規表現にしたものが上のスクリプトです．これから求めた URI References の正規表現は次のようになりました．<BLOCKQUOTE><PRE>(?:(?:[a-z]|[A-Z])(?:(?:[a-z]|[A-Z])|[0-9]|[-+.])*:(?:(?://(?:(?:(?:(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[;:&amp;=+$,])*@)?(?:(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|(?:(?:[a-z]|[A-Z])|[0-9])(?:(?:(?:[a-z]|[A-Z])|[0-9])|-)*(?:(?:[a-z]|[A-Z])|[0-9]))\.)*(?:(?:[a-z]|[A-Z])|(?:[a-z]|[A-Z])(?:(?:(?:[a-z]|[A-Z])|[0-9])|-)*(?:(?:[a-z]|[A-Z])|[0-9]))\.?|[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(?::[0-9]*)?)?|(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[$,;:@&amp;=+])+)(?:/(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*(?:;(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*)*(?:/(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*(?:;(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*)*)*)?|/(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*(?:;(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*)*(?:/(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*(?:;(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*)*)*)(?:\?(?:[;/?:@&amp;=+$,]|(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f]))*)?|(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[;?:@&amp;=+$,])(?:[;/?:@&amp;=+$,]|(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f]))*)|(?://(?:(?:(?:(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[;:&amp;=+$,])*@)?(?:(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|(?:(?:[a-z]|[A-Z])|[0-9])(?:(?:(?:[a-z]|[A-Z])|[0-9])|-)*(?:(?:[a-z]|[A-Z])|[0-9]))\.)*(?:(?:[a-z]|[A-Z])|(?:[a-z]|[A-Z])(?:(?:(?:[a-z]|[A-Z])|[0-9])|-)*(?:(?:[a-z]|[A-Z])|[0-9]))\.?|[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(?::[0-9]*)?)?|(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[$,;:@&amp;=+])+)(?:/(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*(?:;(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*)*(?:/(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*(?:;(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*)*)*)?|/(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*(?:;(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*)*(?:/(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*(?:;(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*)*)*|(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[;@&amp;=+$,])+(?:/(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*(?:;(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*)*(?:/(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*(?:;(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*)*)*)?)(?:\?(?:[;/?:@&amp;=+$,]|(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f]))*)?)?(?:#(?:[;/?:@&amp;=+$,]|(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f]))*)?</PRE></BLOCKQUOTE><P>この正規表現はあまりにも一般的すぎて，ほとんどの入力に対してマッチしてしまいます．<NOBR>RFC 2396</NOBR> はもともと URI の一般形を定義したものであるので，この正規表現を使うことはほとんどないと言っていいでしょう．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="httpURL"><HR></A><H2><NOBR>http URL</NOBR> の正規表現</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># $http が正しい http URL か判定する$digit = q{[0-9]};$upalpha = q{[A-Z]};$lowalpha = q{[a-z]};$alpha = qq{(?:$lowalpha|$upalpha)};$alphanum = qq{(?:$alpha|$digit)};$hex = qq{(?:$digit|[A-Fa-f])};$escaped = qq{%$hex$hex};$mark = q{[-_.!~*'()]};$unreserved = qq{(?:$alphanum|$mark)};$reserved = q{[;/?:@&amp;=+$,]};$uric = qq{(?:$reserved|$unreserved|$escaped)};$query = qq{$uric*};$pchar = qq{(?:$unreserved|$escaped|} . q{[:@&amp;=+$,])};$param = qq{$pchar*};$segment = qq{$pchar*(?:;$param)*};$path_segments = qq{$segment(?:/$segment)*};$abs_path = qq{/$path_segments};$port = qq{$digit*};$IPv4address = qq{$digit+\\.$digit+\\.$digit+\\.$digit+};$toplabel = qq{(?:$alpha|$alpha(?:$alphanum|-)*$alphanum)};$domainlabel = qq{(?:$alphanum|$alphanum(?:$alphanum|-)*$alphanum)};$hostname = qq{(?:$domainlabel\\.)*$toplabel\\.?};$host = qq{(?:$hostname|$IPv4address)};$http_URL = qq{http://$host(?::$port)?(?:$abs_path(?:\\?$query)?)?};$pattern = $http_URL;print &quot;ok\n&quot; if $http =~ /^$pattern$/;</PRE></B></BLOCKQUOTE><P><NOBR>http URL</NOBR> については<A HREF="http://www.csl.sony.co.jp/cgi-bin/hyperrfc?2616"><NOBR>RFC 2616</NOBR></A> の <NOBR>3.2.2 http URL</NOBR> に書かれています．このスクリプトは，「<A HREF="#URI">URI(URL) の正規表現</A>」で書いた URI(URL) の正規表現のスクリプトを修正し， <NOBR>http URL</NOBR>の正規表現にしたものです．このスクリプトから求めた <NOBR>http URL</NOBR>の正規表現は次のようになりました．<BLOCKQUOTE><PRE>http://(?:(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|(?:(?:[a-z]|[A-Z])|[0-9])(?:(?:(?:[a-z]|[A-Z])|[0-9])|-)*(?:(?:[a-z]|[A-Z])|[0-9]))\.)*(?:(?:[a-z]|[A-Z])|(?:[a-z]|[A-Z])(?:(?:(?:[a-z]|[A-Z])|[0-9])|-)*(?:(?:[a-z]|[A-Z])|[0-9]))\.?|[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(?::[0-9]*)?(?:/(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*(?:;(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*)*(?:/(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*(?:;(?:(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f])|[:@&amp;=+$,])*)*)*(?:\?(?:[;/?:@&amp;=+$,]|(?:(?:(?:[a-z]|[A-Z])|[0-9])|[-_.!~*'()])|%(?:[0-9]|[A-Fa-f])(?:[0-9]|[A-Fa-f]))*)?)?</PRE></BLOCKQUOTE><P>この <NOBR>http URL</NOBR> の正規表現は，文字クラス同士の選択がまとめられていないので無駄が多いことがわかります．そこで，文字クラスをなるべくまとめるように以下のように一部改良します．<BLOCKQUOTE><B><PRE># $http が正しい http URL か判定する(文字クラス改良版)$alpha = q{[a-zA-Z]};$alphanum = q{[a-zA-Z0-9]};$hex = q{[0-9A-Fa-f]};$uric = q{(?:[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,]} . qq{|$escaped)};$pchar = q{(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]} . qq{|$escaped)};$toplabel = qq{(?:$alpha|$alpha} . q{[-a-zA-Z0-9]*} . qq{$alphanum)};$domainlabel = qq{(?:$alphanum|$alphanum} . q{[-a-zA-Z0-9]*} . qq{$alphanum)};</PRE></B></BLOCKQUOTE><P>このスクリプトから求めた <NOBR>http URL</NOBR> の正規表現は次のようになりました．<BLOCKQUOTE><PRE>http://(?:(?:(?:[a-zA-Z0-9]|[a-zA-Z0-9][-a-zA-Z0-9]*[a-zA-Z0-9])\.)*(?:[a-zA-Z]|[a-zA-Z][-a-zA-Z0-9]*[a-zA-Z0-9])\.?|[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(?::[0-9]*)?(?:/(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*(?:;(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)*(?:/(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*(?:;(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)*)*(?:\?(?:[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)?)?</PRE></BLOCKQUOTE><P>この正規表現は前述しましたが，<NOBR>RFC 2616</NOBR> の<NOBR>3.2.2 http URL</NOBR> に書かれています．<NOBR>RFC 2616</NOBR> にはHTTPプロトコルに関することが書かれており，<NOBR>3.2.2 http URL</NOBR>に書かれている <NOBR>http URL</NOBR> も，HTTPプロトコルの中での話になります．一般に，HTML のリンクに使用されるものは，純粋にHTTPプロトコルの中で使用される <NOBR>http URL</NOBR> ではなく，scheme が http である<NOBR>URI References</NOBR> です．<P>たとえば<NOBR><TT>http://user:passwd@www.din.or.jp/~ohzaki/perl.htm#URI</TT></NOBR>は <NOBR>URI References</NOBR> ですが，<NOBR><TT>user:passwd@</TT></NOBR>の部分，すなわち，userinfo や，<NOBR><TT>#URI</TT></NOBR> の部分，すなわち，<NOBR>Fragment Identifier</NOBR> は HTTPプロトコルの中で使用される<NOBR>http URL</NOBR> としては不正なものとなります．しかし，HTMLのリンクとしては問題ありません．なぜなら，クライアント(ブラウザ)がHTTPプロトコルで通信する際にはそれらを削除しているからです．余談ですが，<A HREF="http://www.csl.sony.co.jp/cgi-bin/hyperrfc?2396"><NOBR>RFC 2396</NOBR></A>(<A HREF="http://member.nifty.ne.jp/moha/rfc/rfc2396j.txt">日本語訳</A> ) の<NOBR>第 4章</NOBR>には<FONT COLOR="Blue"><NOBR>Fragment Identifier</NOBR> は URIの一部ではない</FONT>と書かれています．<NOBR>Fragment Identifier</NOBR> は<NOBR>user agent</NOBR> によって解釈される付加的参照情報だそうです．<P>次に，scheme が http である <NOBR>URI References</NOBR> を考えます．そこで再び「<A HREF="#URI">URI(URL) の正規表現</A>」で書いた URI(URL) の正規表現のスクリプトを修正して作ります．その際，HTTPプロトコルの中で使用される <NOBR>http URL</NOBR>を構築するのに必要な情報を必ず含んでいれば，それ以外に冗長な情報を含んでいてもよいとします．必要な情報とは，host，port，abs_path，query です．また，scheme は当然 http ですが，この際，Secure Hyper Text Tranasfer Protocol(S-HTTP)と呼ばれるプロトコルを使う <NOBR><TT>shttp:</TT></NOBR> や Secure Sockets Layer(SSL)というプロトコルを使う <NOBR><TT>https:</TT></NOBR>にも対応するようにしておきます．修正した結果は，以下のように一部を修正することになりました．<BLOCKQUOTE><B><PRE>$server = qq{(?:$userinfo\@)?$hostport};$authority = qq{$server};$scheme = q{(?:https?|shttp)};$hier_part = qq{$net_path(?:\\?$query)?};$absoluteURI = qq{$scheme:$hier_part};$URI_reference = qq{$absoluteURI(?:#$fragment)?};</PRE></B></BLOCKQUOTE><P>これに先ほどと同じように文字クラスをまとめる改良として，以下のように一部を修正しました．<BLOCKQUOTE><B><PRE>$alpha = q{[a-zA-Z]};$alphanum = q{[a-zA-Z0-9]};$hex = q{[0-9A-Fa-f]};$unreserved = q{[-_.!~*'()a-zA-Z0-9]};$uric = q{(?:[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,]} . qq{|$escaped)};$pchar = q{(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]} . qq{|$escaped)};$toplabel = qq{(?:$alpha|$alpha} . q{[-a-zA-Z0-9]*} . qq{$alphanum)};$domainlabel = qq{(?:$alphanum|$alphanum} . q{[-a-zA-Z0-9]*} . qq{$alphanum)};$userinfo = q{(?:[-_.!~*'()a-zA-Z0-9;:&amp;=+$,]|} . qq{$escaped)*};</PRE></B></BLOCKQUOTE><P>このようにして求めた正規表現は次のようになりました．<BLOCKQUOTE><PRE>(?:https?|shttp)://(?:(?:[-_.!~*'()a-zA-Z0-9;:&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*@)?(?:(?:(?:[a-zA-Z0-9]|[a-zA-Z0-9][-a-zA-Z0-9]*[a-zA-Z0-9])\.)*(?:[a-zA-Z]|[a-zA-Z][-a-zA-Z0-9]*[a-zA-Z0-9])\.?|[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(?::[0-9]*)?(?:/(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*(?:;(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)*(?:/(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*(?:;(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)*)*)?(?:\?(?:[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)?(?:#(?:[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)?</PRE></BLOCKQUOTE><P>この正規表現を使えば， <NOBR><CODE>$http</CODE></NOBR> が，scheme が http である <NOBR>URI References</NOBR>かどうか判定することはできます．ところが，<FONT COLOR="Red">ある文字列の中から <NOBR>http URL</NOBR> を抽出する目的でこの正規表現を使ってもうまくいきません</FONT>．たとえば，次のようなスクリプトを実行するとうまくいかないことがわかります．<BLOCKQUOTE><PRE># $str から http URI References を抽出する$str = &quot;このページの URI は http://www.din.or.jp/~ohzaki/perl.htm です&quot;;$pattern = $URI_reference;while ($str =~ /($pattern)/g) {  print $1, &quot;\n&quot;;}実行結果(失敗例)http://www.din.or.j</PRE></BLOCKQUOTE><P>なぜこのような結果になってしまったのでしょうか．それは Perl のパターンマッチエンジンが<FONT COLOR="Blue">非決定性有限オートマトンNFAs(Nondeterministic Finite Automata)</FONT> だからです．次のようなスクリプトを考えてみてください．<BLOCKQUOTE><PRE>print &quot;数字 1文字 or 数字で始まり数字か小文字が続くもの\n&quot;;$str = '123abc';@patterns = ('(?:\d|\d[0-9a-z]+)', '(?:\d[0-9a-z]*)');foreach $pattern (@patterns) {  print &quot;  文字列 $str  パターン $pattern  &quot;;  print '結果 ' . join('/', $str =~ /$pattern/g) . &quot;\n&quot;;}print &quot;\n数字 1文字 or 最初が数字か小文字で，次が小文字のもの\n&quot;;$str = '1a';@patterns = ('(?:\d|[\da-z][a-z])', '(?:[\da-z][a-z]|\d)');foreach $pattern (@patterns) {  print &quot;  文字列 $str  パターン $pattern  &quot;;  print '結果 ' . join('/', $str =~ /$pattern/g) . &quot;\n&quot;;}実行結果数字 1文字 or 最初が数字で，その後数字か小文字が続くもの  文字列 123abc  パターン (?:\d|\d[0-9a-z]+)  結果 1/2/3  文字列 123abc  パターン (?:\d[0-9a-z]*)  結果 123abc数字 1文字 or 最初が数字か小文字で，次が小文字のもの  文字列 1a  パターン (?:\d|[\da-z][a-z])  結果 1  文字列 1a  パターン (?:[\da-z][a-z]|\d)  結果 1a</PRE></BLOCKQUOTE><P>2つの例のうち，どちらも最初の正規表現では文字列の一部にしかマッチしていないことがわかると思います．このように Perl のパターンマッチエンジンはうまくマッチさせていけば もっと長い文字列にマッチさせることができる場合でも，最初に見つかった方法でパターンマッチを進めてしまいます．それではなぜもう一方の正規表現ではうまく文字列全体にマッチさせることができたのでしょうか．<P>1つめの例では，<NOBR><CODE>(?:<I>regex1</I>|<I>regex1</I><I>regex2+</I>)</CODE></NOBR>という選択を<NOBR><CODE><I>regex1</I><I>regex2</I>*</CODE></NOBR> という形に変形し，選択が現れないようにしています．このようにすることで，より長くマッチさせることができ，また，ほとんどの場合に<FONT COLOR="Blue">バックトラック</FONT>を減らすことができるので効率的になります．これと同じこと行ない，以下のように一部改良します．<BLOCKQUOTE><B><PRE>$toplabel = qq{$alpha(?:} . q{[-a-zA-Z0-9]*} . qq{$alphanum)?};$domainlabel = qq{$alphanum(?:} . q{[-a-zA-Z0-9]*} . qq{$alphanum)?};</PRE></B></BLOCKQUOTE><P>2つめの例では，<NOBR><CODE>(?:<I>regex1</I>|<I>regex2</I>)</CODE></NOBR>という選択で，<NOBR><CODE><I>regex1</I></CODE></NOBR> が<NOBR><CODE><I>regex2</I></CODE></NOBR> の一部とマッチしてしまう場合に，より長くマッチできる可能性である．<NOBR><CODE><I>regex2</I></CODE></NOBR>を試すことなく <NOBR><CODE><I>regex1</I></CODE></NOBR> が選択されてしまったために文字列の一部にマッチしてしまったのです．選択を逆にした，<NOBR><CODE>(?:<I>regex2</I>|<I>regex1</I>)</CODE></NOBR>の形に修正することで，このような事態を避けることができます．実際にその可能性のある選択を持つ部分というと，host の正規表現の hostname とIPv4address の選択の部分になります．なぜなら，IPv4address の正規表現はhostname の一部とマッチしてしまう可能性があるからです．例えば，<NOBR>127.0.0.1.www.din.or.jp</NOBR> という host があった場合，先にIPv4address をマッチさせてしまうと <NOBR>127.0.0.1</NOBR> の部分にマッチしてしまいます．幸い，最初から host の正規表現は先に hostnameをマッチさせるようになっていますので，特に修正する必要はないことになります．<P>最後に，<NOBR><TT>pseudohttp://foo/bar.htm</TT></NOBR> のようにHTTP ではない scheme の途中からマッチしてしまうことがないように，以下のように改良します．<BLOCKQUOTE><B><PRE>$http_URL_regex = q{\b} . $URI_reference;</PRE></B></BLOCKQUOTE><P>以上の改良をすべてまとめた最終的なスクリプトは以下のようになりました．<BLOCKQUOTE><B><PRE># http URL の正規表現 $http_URL_regex$digit = q{[0-9]};$alpha = q{[a-zA-Z]};$alphanum = q{[a-zA-Z0-9]};$hex = q{[0-9A-Fa-f]};$escaped = qq{%$hex$hex};$uric = q{(?:[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,]} . qq{|$escaped)};$fragment = qq{$uric*};$query = qq{$uric*};$pchar = q{(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]} . qq{|$escaped)};$param = qq{$pchar*};$segment = qq{$pchar*(?:;$param)*};$path_segments = qq{$segment(?:/$segment)*};$abs_path = qq{/$path_segments};$port = qq{$digit*};$IPv4address = qq{$digit+\\.$digit+\\.$digit+\\.$digit+};$toplabel = qq{$alpha(?:} . q{[-a-zA-Z0-9]*} . qq{$alphanum)?};$domainlabel = qq{$alphanum(?:} . q{[-a-zA-Z0-9]*} . qq{$alphanum)?};$hostname = qq{(?:$domainlabel\\.)*$toplabel\\.?};$host = qq{(?:$hostname|$IPv4address)};$hostport = qq{$host(?::$port)?};$userinfo = q{(?:[-_.!~*'()a-zA-Z0-9;:&amp;=+$,]|} . qq{$escaped)*};$server = qq{(?:$userinfo\@)?$hostport};$authority = qq{$server};$scheme = q{(?:https?|shttp)};$net_path = qq{//$authority(?:$abs_path)?};$hier_part = qq{$net_path(?:\\?$query)?};$absoluteURI = qq{$scheme:$hier_part};$URI_reference = qq{$absoluteURI(?:#$fragment)?};$http_URL_regex = q{\b} . $URI_reference;</PRE></B></BLOCKQUOTE><P>このスクリプトから求めた <NOBR>http URL</NOBR> の正規表現は次のようになりました．<BLOCKQUOTE><B><PRE>\b(?:https?|shttp)://(?:(?:[-_.!~*'()a-zA-Z0-9;:&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*@)?(?:(?:[a-zA-Z0-9](?:[-a-zA-Z0-9]*[a-zA-Z0-9])?\.)*[a-zA-Z](?:[-a-zA-Z0-9]*[a-zA-Z0-9])?\.?|[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(?::[0-9]*)?(?:/(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*(?:;(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)*(?:/(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*(?:;(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)*)*)?(?:\?(?:[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)?(?:#(?:[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)?</PRE></B></BLOCKQUOTE><P>この正規表現を使えば，<NOBR>http URL</NOBR> の抽出がうまくいくようになります．以下がこれを直接代入して使うスクリプトになります．<BLOCKQUOTE><B><PRE>$http_URL_regex =q{\b(?:https?|shttp)://(?:(?:[-_.!~*'()a-zA-Z0-9;:&amp;=+$,]|%[0-9A-Fa-f} .q{][0-9A-Fa-f])*@)?(?:(?:[a-zA-Z0-9](?:[-a-zA-Z0-9]*[a-zA-Z0-9])?\.)} .q{*[a-zA-Z](?:[-a-zA-Z0-9]*[a-zA-Z0-9])?\.?|[0-9]+\.[0-9]+\.[0-9]+\.} .q{[0-9]+)(?::[0-9]*)?(?:/(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f]} .q{[0-9A-Fa-f])*(?:;(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-} .q{Fa-f])*)*(?:/(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f} .q{])*(?:;(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)*)} .q{*)?(?:\?(?:[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])} .q{*)?(?:#(?:[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*} .q{)?};</PRE></B></BLOCKQUOTE><P>さて，ここまで長々と書いてきましたが，正確に正規表現を書くことをあきらめて，もっと簡単でいいやという人のための <NOBR>http URL</NOBR>の正規表現が以下になります．<BLOCKQUOTE><B><PRE>s?https?://[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,%#]+</PRE></B></BLOCKQUOTE><P>この正規表現を一旦変数に代入して使用する場合は問題ありませんが，直接正規表現として利用する場合は次のように書く必要があります．<BLOCKQUOTE><PRE># 文書 $text から http URL を抽出して @http に格納する@http = $text =~ /s?https?:\/\/[-_.!~*'()a-zA-Z0-9;\/?:\@&amp;=+\$,%#]+/g;</PRE></BLOCKQUOTE><P><CODE>/</CODE> が <NOBR><CODE>\/</CODE></NOBR>になっているのは問題ないと思います．特に注意しなければいけないのは，<CODE>$</CODE> と <CODE>@</CODE>の部分です．これらはそのままではそれぞれスカラー変数・配列変数として扱われ，<FONT COLOR="Blue">変数展開</FONT>の対象となってしまいます．そこでこの<NOBR>2つ</NOBR>についても <NOBR><CODE>\$</CODE></NOBR> と<NOBR><CODE>\@</CODE></NOBR> のようにする必要があります．もし，この<NOBR>2つ</NOBR>に <CODE>\</CODE> をつけ忘れていた場合はどうなるのか？そのときは，<CODE>$</CODE> については<FONT COLOR="Blue"><NOBR>特殊変数<CODE>$,</CODE></NOBR></FONT> として通常は空文字列に展開されてしまいます．<CODE>@</CODE> については <NOBR><CODE>@&amp;</CODE></NOBR>で始まるような配列変数は存在しないので，配列変数としては扱われずそのままになります．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="ftpURL"><HR></A><H2><NOBR>ftp URL</NOBR> の正規表現</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># ftp URL の正規表現 $ftp_URL_regex$digit = q{[0-9]};$alpha = q{[a-zA-Z]};$alphanum = q{[a-zA-Z0-9]};$hex = q{[0-9A-Fa-f]};$escaped = qq{%$hex$hex};$uric = q{(?:[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,]} . qq{|$escaped)};$fragment = qq{$uric*};$query = qq{$uric*};$pchar = q{(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]} . qq{|$escaped)};$segment = qq{$pchar*};$ftptype = q{[AIDaid]};$path_segments = qq{$segment(?:/$segment)*(?:;type=$ftptype)?};$abs_path = qq{/$path_segments};$port = qq{$digit*};$IPv4address = qq{$digit+\\.$digit+\\.$digit+\\.$digit+};$toplabel = qq{$alpha(?:} . q{[-a-zA-Z0-9]*} . qq{$alphanum)?};$domainlabel = qq{$alphanum(?:} . q{[-a-zA-Z0-9]*} . qq{$alphanum)?};$hostname = qq{(?:$domainlabel\\.)*$toplabel\\.?};$host = qq{(?:$hostname|$IPv4address)};$hostport = qq{$host(?::$port)?};$user = q{(?:[-_.!~*'()a-zA-Z0-9;&amp;=+$,]|} . qq{$escaped)*};$password = $user;$userinfo = qq{$user(?::$password)?};$server = qq{(?:$userinfo\@)?$hostport};$authority = qq{$server};$scheme = q{ftp};$net_path = qq{//$authority(?:$abs_path)?};$hier_part = qq{$net_path(?:\\?$query)?};$absoluteURI = qq{$scheme:$hier_part};$URI_reference = qq{$absoluteURI(?:#$fragment)?};$ftp_URL_regex = q{\b} . $URI_reference;</PRE></B></BLOCKQUOTE><P><NOBR>ftp URL</NOBR> については<A HREF="http://www.csl.sony.co.jp/cgi-bin/hyperrfc?1738"><NOBR>RFC 1738</NOBR></A> に書かれています．ただし，現在では<NOBR>RFC 1738</NOBR> は<A HREF="http://www.csl.sony.co.jp/cgi-bin/hyperrfc?2396"><NOBR>RFC 2396</NOBR></A>(<A HREF="http://member.nifty.ne.jp/moha/rfc/rfc2396j.txt">日本語訳</A> )によって更新されています．更新されていると言っても<NOBR>RFC 2396</NOBR> は URI の一般形を定義したものになっているので，<NOBR>ftp URL</NOBR> の定義について直接書かれている部分はありません．そこで，<NOBR>ftp URL</NOBR>の正規表現として，<NOBR>RFC 2396</NOBR>の URI の一般形の定義をもとに，「<A HREF="#httpURL"><NOBR>http URL</NOBR> の正規表現</A>」でスキームがhttp である <NOBR>URI References</NOBR> として求めた方法と同様の方法で，スキームが ftp である <NOBR>URI References</NOBR> を考えます．<P><NOBR>RFC 1738</NOBR> に書かれている <NOBR>ftp URL</NOBR>の定義を考慮して書き換えた部分は以下のようになります．<BLOCKQUOTE><PRE>$segment = qq{$pchar*};$ftptype = q{[AIDaid]};$path_segments = qq{$segment(?:/$segment)*(?:;type=$ftptype)?};$user = q{(?:[-_.!~*'()a-zA-Z0-9;&=+$,]|} . qq{$escaped)*};$password = $user;$userinfo = qq{$user(?::$password)?};$server = qq{(?:$userinfo\@)?$hostport};$authority = qq{$server};$scheme = q{ftp};$net_path = qq{//$authority(?:$abs_path)?};$hier_part = qq{$net_path(?:\\?$query)?};$absoluteURI = qq{$scheme:$hier_part};$URI_reference = qq{$absoluteURI(?:#$fragment)?};$ftp_URL_regex = q{\b} . $URI_reference;</PRE></BLOCKQUOTE><P><NOBR>ftp URL</NOBR> は <NOBR>RFC 1738</NOBR> で<NOBR>ftpurl = "ftp://" login [ "/" fpath [ ";type=" ftptype ]]</NOBR>と定義されています．login より後ろの部分は path_segments に当たるわけですが，; は fpath とその後ろの部分を区切る目的で使用されます．そこで，segment から; と param を削除し，path_segments を <NOBR>ftp URL</NOBR>の定義に適合するように修正しました．同様に login 部分は<NOBR>login = [ user [ ":" password ] "@" ] hostport</NOBR> と定義されており，userinfo は <NOBR>user [ ":" password ]</NOBR> となっています．つまり，:が user と password を区切る目的で使用されるため，userinfo から :を取り除いたものを新たに user，password として定義し userinfo を修正しました．scheme は当然 ftp であり，スキームが ftp である <NOBR>URI References</NOBR>としてはあり得ない選択部分を削除するなどして URI_reference や absoluteURIなどを修正しました．<P>このスクリプトから求めた <NOBR>ftp URL</NOBR> の正規表現は次のようになりました． <BLOCKQUOTE><B><PRE>\bftp://(?:(?:[-_.!~*'()a-zA-Z0-9;&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*(?::(?:[-_.!~*'()a-zA-Z0-9;&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)?@)?(?:(?:[a-zA-Z0-9](?:[-a-zA-Z0-9]*[a-zA-Z0-9])?\.)*[a-zA-Z](?:[-a-zA-Z0-9]*[a-zA-Z0-9])?\.?|[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(?::[0-9]*)?(?:/(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*(?:/(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)*(?:;type=[AIDaid])?)?(?:\?(?:[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)?(?:#(?:[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)?</PRE></B></BLOCKQUOTE><P>以下がこれを直接代入して使うスクリプトになります．<BLOCKQUOTE><B><PRE>$ftp_URL_regex =q{\bftp://(?:(?:[-_.!~*'()a-zA-Z0-9;&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*} .q{(?::(?:[-_.!~*'()a-zA-Z0-9;&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)?@)?(?} .q{:(?:[a-zA-Z0-9](?:[-a-zA-Z0-9]*[a-zA-Z0-9])?\.)*[a-zA-Z](?:[-a-zA-} .q{Z0-9]*[a-zA-Z0-9])?\.?|[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(?::[0-9]*)?} .q{(?:/(?:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*(?:/(?} .q{:[-_.!~*'()a-zA-Z0-9:@&amp;=+$,]|%[0-9A-Fa-f][0-9A-Fa-f])*)*(?:;type=[} .q{AIDaid])?)?(?:\?(?:[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,]|%[0-9A-Fa-f][0-9} .q{A-Fa-f])*)?(?:#(?:[-_.!~*'()a-zA-Z0-9;/?:@&amp;=+$,]|%[0-9A-Fa-f][0-9A} .q{-Fa-f])*)?};</PRE></B></BLOCKQUOTE></BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="Mail"><HR></A><H2>メールアドレスの正規表現</H2><BLOCKQUOTE><P><FONT COLOR="Red"><NOBR>RFC 821</NOBR> と <NOBR>RFC 822</NOBR> は<A HREF="http://www.csl.sony.co.jp/cgi-bin/hyperrfc?2821"><NOBR>RFC 2821</NOBR></A>( 日本語訳<A HREF="http://www.puni.net/~mimori/rfc/rfc2821a.txt">1〜3章</A><A HREF="http://www.puni.net/~mimori/rfc/rfc2821b.txt">4,5章</A><A HREF="http://www.puni.net/~mimori/rfc/rfc2821c.txt">6章〜</A>)と<A HREF="http://www.csl.sony.co.jp/cgi-bin/hyperrfc?2822"><NOBR>RFC 2822</NOBR></A>(<A HREF="http://www.puni.net/~mimori/rfc/rfc2822.txt">日本語訳</A> )によって obsolete となりました．</FONT><P>メールアドレスについては<A HREF="http://www.csl.sony.co.jp/cgi-bin/hyperrfc?821"><NOBR>RFC 821</NOBR></A>(<A HREF="http://www.asahi-net.or.jp/~bd9y-ktu/dtd_f/rfc_f/rfc821j.html">日本語訳</A> )と<A HREF="http://www.csl.sony.co.jp/cgi-bin/hyperrfc?822"><NOBR>RFC 822</NOBR></A>(<A HREF="http://www.asahi-net.or.jp/~bd9y-ktu/dtd_f/rfc_f/rfc822j.html">日本語訳</A> )に書かれています．<NOBR>perl5.6.0</NOBR>以前の perlでは<FONT COLOR="Red">メールアドレスの正規表現を正確に記述することはできませんでした</FONT>．<NOBR>Jeffrey E. F. Friedl</NOBR>氏原著による「<A HREF="http://www.oreilly.co.jp/BOOK/regex.htm">詳説 正規表現</A>(<A HREF="http://www.oreilly.com/catalog/regex/">Mastering Regular Expressions </A>)」にはメールアドレスはネストしたコメントを持つことができるので正規表現で表わすのは不可能であると書いてあります．そこで，<NOBR>Jeffrey E. F. Friedl</NOBR>氏はネストしたコメントをあきらめて，次のような <NOBR>6,598バイト</NOBR>にも及ぶ正規表現を作っています．<A HREF="http://public.yahoo.com/~jfriedl/regex/email-opt.pl"><NOBR>http://public.yahoo.com/~jfriedl/regex/email-opt.pl</NOBR></A>にソースコードがあります．<BLOCKQUOTE><PRE>[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|&quot;[^\\\x80-\xff\n\015&quot;]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015&quot;]*)*&quot;)[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|&quot;[^\\\x80-\xff\n\015&quot;]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015&quot;]*)*&quot;)[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*@[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*|(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|&quot;[^\\\x80-\xff\n\015&quot;]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015&quot;]*)*&quot;)[^()&lt;&gt;@,;:&quot;.\\\[\]\x80-\xff\000-\010\012-\037]*(?:(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)|&quot;[^\\\x80-\xff\n\015&quot;]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015&quot;]*)*&quot;)[^()&lt;&gt;@,;:&quot;.\\\[\]\x80-\xff\000-\010\012-\037]*)*&lt;[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:@[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*(?:,[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*@[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*)*:[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)?(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|&quot;[^\\\x80-\xff\n\015&quot;]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015&quot;]*)*&quot;)[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|&quot;[^\\\x80-\xff\n\015&quot;]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015&quot;]*)*&quot;)[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*@[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:\.[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])[\040\t]*(?:\([^\\\x80-\xff\n\015()]*(?:(?:\\[^\x80-\xff]|\([^\\\x80-\xff\n\015()]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015()]*)*\))[^\\\x80-\xff\n\015()]*)*\)[\040\t]*)*)*&gt;)</PRE></BLOCKQUOTE><P><NOBR><TT>email-opt.pl</TT></NOBR> を元に冗長部分を削り落としたのが以下のスクリプトです．冗長部分を削り落としてもかなりの量です．<BLOCKQUOTE><B><PRE># $email が正しいメールアドレスか判定する$esc         = '\\\\';               $Period      = '\.';$space       = '\040';               $tab         = '\t';$OpenBR      = '\[';                 $CloseBR     = '\]';$OpenParen   = '\(';                 $CloseParen  = '\)';$NonASCII    = '\x80-\xff';          $ctrl        = '\000-\037';$CRlist      = '\n\015';$qtext       = qq/[^$esc$NonASCII$CRlist\&quot;]/;$dtext       = qq/[^$esc$NonASCII$CRlist$OpenBR$CloseBR]/;$quoted_pair = qq&lt;${esc}[^$NonASCII]&gt;;$ctext       = qq&lt;[^$esc$NonASCII$CRlist()]&gt;;$Cnested     = qq&lt;$OpenParen$ctext*(?:$quoted_pair$ctext*)*$CloseParen&gt;;$comment     =    qq&lt;$OpenParen$ctext*(?:(?:$quoted_pair|$Cnested)$ctext*)*$CloseParen&gt;;$X           = qq&lt;[$space$tab]*(?:${comment}[$space$tab]*)*&gt;;$atom_char   = qq/[^($space)&lt;&gt;\@,;:\&quot;.$esc$OpenBR$CloseBR$ctrl$NonASCII]/;$atom        = qq&lt;$atom_char+(?!$atom_char)&gt;;$quoted_str  = qq&lt;\&quot;$qtext*(?:$quoted_pair$qtext*)*\&quot;&gt;;$word        = qq&lt;(?:$atom|$quoted_str)&gt;;$domain_ref  = $atom;$domain_lit  = qq&lt;$OpenBR(?:$dtext|$quoted_pair)*$CloseBR&gt;;$sub_domain  = qq&lt;(?:$domain_ref|$domain_lit)$X&gt;;$domain      = qq&lt;$sub_domain(?:$Period$X$sub_domain)*&gt;;$route       = qq&lt;\@$X$domain(?:,$X\@$X$domain)*:$X&gt;;$local_part  = qq&lt;$word$X(?:$Period$X$word$X)*&gt;;$addr_spec   = qq&lt;$local_part\@$X$domain&gt;;$route_addr  = qq[&lt;$X(?:$route)?$addr_spec&gt;];$phrase_ctrl = '\000-\010\012-\037';$phrase_char =   qq/[^()&lt;&gt;\@,;:\&quot;.$esc$OpenBR$CloseBR$NonASCII$phrase_ctrl]/;$phrase      =    qq&lt;$word$phrase_char*(?:(?:$comment|$quoted_str)$phrase_char*)*&gt;;$mailbox     = qq&lt;$X(?:$addr_spec|$phrase$route_addr)&gt;;print &quot;ok\n&quot; if $email =~ /^$mailbox$/o;</PRE></B></BLOCKQUOTE><P><NOBR>perl5.6.0</NOBR>以前の perl では表現できなかったネストしたコメント部分は，このスクリプトでは <NOBR><CODE>$Cnested</CODE></NOBR> と<NOBR><CODE>$comment</CODE></NOBR> の代入文で定義されており，<FONT COLOR="Red"><NOBR>1回</NOBR>だけネストを許した正規表現</FONT>となっています．この<NOBR>2つ</NOBR>の代入文を以下のように変更することで<FONT COLOR="Red">メールアドレスの正規表現を正確に記述することができる</FONT>ようになります．<BLOCKQUOTE><B><PRE>use re 'eval';$comment     =  qr&lt;$OpenParen$ctext*(?:(?:$quoted_pair|(??{$comment}))$ctext*)*$CloseParen&gt;;</PRE></B></BLOCKQUOTE><P>ただし，ここで使用している正規表現 <FONT COLOR="Blue"><NOBR><CODE>(??{ code })</CODE></NOBR></FONT> は実験的なものなので今後変更されたり削除されるかもしれませんので注意が必要です．また， <NOBR><CODE>use re 'eval';</CODE></NOBR>しているので，この点にも十分注意する必要があります．何をどう注意する必要があるのかはマニュアルを読んでください．メールアドレスのパターンマッチが終わった時点で<NOBR><CODE>no re 'eval';</CODE></NOBR> しておくことをお勧めします．<P>メールアドレスが正しいかどうかを調べるには<A HREF="http://www2.classmates.com/~maurice/"><NOBR>モジュール<CODE>Email::Valid</CODE></NOBR></A> または<A HREF="http://search.cpan.org/search?dist=Mail-CheckUser"><NOBR>モジュール<CODE>Mail::CheckUser</CODE></NOBR></A> を使うのがいいと思います．このモジュールを使えば，メールアドレスが <NOBR>RFC 822</NOBR>に書かれている文法的に正しいかどうかだけではなく，そのメールアドレスが実際に有効かどうかもある程度調べることができます．ただし，その場合はもちろんインターネットに接続されている必要があります．詳しい使い方はマニュアルを読んでください．<P>さて，ここまでで書いてきたメールアドレスというのは<NOBR>From行</NOBR>などで指定できるもののことでして，<NOBR>RFC 822</NOBR>においては <FONT COLOR="Blue">mailbox</FONT> として定義されています．この mailbox をある文字列からメールアドレスを抽出する目的で使うのは無茶というものです．そのような目的のときに必要とされるのは mailbox ではなく，<FONT COLOR="Blue"><NOBR>addr-spec</NOBR></FONT> の方でしょう．mailbox や<NOBR>addr-spec</NOBR> がどのようなものかと言いますと，たとえば，<NOBR><TT>OHZAKI Hiroki &lt;ohzaki@din.or.jp&gt;</TT></NOBR> というのはmailbox ですが <NOBR>addr-spec</NOBR> ではありません．<NOBR><TT>ohzaki@din.or.jp</TT></NOBR> というのは <NOBR>addr-spec</NOBR>だけから成る mailbox になります．<P>そこで先ほどのスクリプトを修正し，ある文字列からメールアドレスを抽出する目的で使うための <NOBR>addr-spec</NOBR> の正規表現を以下のように作りました．<BLOCKQUOTE><B><PRE># メールアドレスの正規表現 $mail_regex$esc         = '\\\\';               $Period      = '\.';$space       = '\040';$OpenBR      = '\[';                 $CloseBR     = '\]';$NonASCII    = '\x80-\xff';          $ctrl        = '\000-\037';$CRlist      = '\n\015';$qtext       = qq/[^$esc$NonASCII$CRlist\&quot;]/;$dtext       = qq/[^$esc$NonASCII$CRlist$OpenBR$CloseBR]/;$quoted_pair = qq&lt;${esc}[^$NonASCII]&gt;;$atom_char   = qq/[^($space)&lt;&gt;\@,;:\&quot;.$esc$OpenBR$CloseBR$ctrl$NonASCII]/;$atom        = qq&lt;$atom_char+(?!$atom_char)&gt;;$quoted_str  = qq&lt;\&quot;$qtext*(?:$quoted_pair$qtext*)*\&quot;&gt;;$word        = qq&lt;(?:$atom|$quoted_str)&gt;;$domain_ref  = $atom;$domain_lit  = qq&lt;$OpenBR(?:$dtext|$quoted_pair)*$CloseBR&gt;;$sub_domain  = qq&lt;(?:$domain_ref|$domain_lit)&gt;;$domain      = qq&lt;$sub_domain(?:$Period$sub_domain)*&gt;;$local_part  = qq&lt;$word(?:$Period$word)*&gt;;$addr_spec   = qq&lt;$local_part\@$domain&gt;;$mail_regex  = $addr_spec;</PRE></B></BLOCKQUOTE><P>このスクリプトは，先ほどのスクリプトから，途中にコメントとスペースやタブがないように変更し，冗長部分を削除したものです．このスクリプトから求めた <NOBR>addr-spec</NOBR> は以下のようになりました．<BLOCKQUOTE><B><PRE>(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|&quot;[^\\\x80-\xff\n\015&quot;]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015&quot;]*)*&quot;)(?:\.(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|&quot;[^\\\x80-\xff\n\015&quot;]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015&quot;]*)*&quot;))*@(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\])(?:\.(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\]))*</PRE></B></BLOCKQUOTE><P>以下がこれを直接代入して使うスクリプトになります．<BLOCKQUOTE><B><PRE>$mail_regex =q{(?:[^(\040)&lt;&gt;@,;:&quot;.\\\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\\} .q{\[\]\000-\037\x80-\xff])|&quot;[^\\\\\x80-\xff\n\015&quot;]*(?:\\\\[^\x80-\xff][} .q{^\\\\\x80-\xff\n\015&quot;]*)*&quot;)(?:\.(?:[^(\040)&lt;&gt;@,;:&quot;.\\\\\[\]\000-\037\x} .q{80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\\\[\]\000-\037\x80-\xff])|&quot;[^\\\\\x80-} .q{\xff\n\015&quot;]*(?:\\\\[^\x80-\xff][^\\\\\x80-\xff\n\015&quot;]*)*&quot;))*@(?:[^(} .q{\040)&lt;&gt;@,;:&quot;.\\\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\\\[\]\0} .q{00-\037\x80-\xff])|\[(?:[^\\\\\x80-\xff\n\015\[\]]|\\\\[^\x80-\xff])*} .q{\])(?:\.(?:[^(\040)&lt;&gt;@,;:&quot;.\\\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,} .q{;:&quot;.\\\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\\\x80-\xff\n\015\[\]]|\\\\[} .q{^\x80-\xff])*\]))*};</PRE></B></BLOCKQUOTE><P>このメールアドレスの正規表現 <NOBR><CODE>$mail_regex</CODE></NOBR>を使って，<NOBR><CODE>$email</CODE></NOBR>が正しいメールアドレスか判定するには次のように書きます．<BLOCKQUOTE><PRE># $email が正しいメールアドレス(addr_spec)か判定するif ($email !~ /^$mail_regex$/o) {  print &quot;不正なメールアドレスです\n&quot;;}</PRE></BLOCKQUOTE><P>余談ですが，DoCoMo(i-mode) と J-Phone(J-Sky) ではメールアドレスとして<NOBR><TT>irregular<FONT COLOR="Red">.</FONT>@docomo.ne.jp</TT></NOBR>のように <TT>@</TT> の直前が <NOBR><TT>.</TT>(ピリオド)</NOBR> であるものも使用できます．しかし，これは <NOBR>RFC 822</NOBR>に適合しない不正なメールアドレスです．<TT>@</TT> の前の<NOBR>local-part</NOBR> の部分では <NOBR><TT>.</TT>(ピリオド)</NOBR>は必ず他の文字に挟まれていなければならないのです．したがって，<NOBR><TT>.</TT>(ピリオド)</NOBR> が先頭にある場合と，<TT>@</TT>の直前にある場合は不正なメールアドレスということになります．DoCoMo(i-mode)同士や J-Phone(J-Sky)同士でのメールのやりとりであれば問題ありませんが，そうでなければ使用するべきではありません．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="JP_EUC_JP"><HR></A><H2>日本語を扱う</H2><BLOCKQUOTE><H3>perl スクリプトは <NOBR>EUC-JP</NOBR> で書く</H3><BLOCKQUOTE><P>perl で日本語を扱うにはいろいろと注意しなければならないことがあります．なぜなら，日本語の文字コードには perl が特別な意味として解釈してしまう文字が含まれているからです．たとえば，perl スクリプトを JISで次のように書いたとします．<BLOCKQUOTE><PRE>$str = &quot;このTESTで充分&quot;;$str =~ s/このTESTで充分/このテストで十分/;  # JIS でも SJIS でも駄目print $str, &quot;\n&quot;;</PRE></BLOCKQUOTE>これを正常に実行することはできません．<NOBR><TT>unmatched () in regexp</TT></NOBR> となってしまうはずです．なぜなら，エスケープシーケンスの <NOBR><TT>ESC ( B</TT></NOBR>が含まれているために，<CODE>(</CODE> をグループ化のための開き括弧として解釈してしまうからです．もちろん，このエラーは閉じ括弧の <CODE>)</CODE>がないために括弧が対応していないというエラーです．それではこのスクリプトを SJIS で書いた場合はどうでしょう．今度は<NOBR><TT>unmatched [] in regexp</TT></NOBR>となってしまうはずです．なぜなら SJIS の「充」の文字コードは<NOBR>0x8F 0x5B</NOBR> であり，<NOBR>0x5B</NOBR> というのは ASCII の<CODE>[</CODE> の文字コードであるからです．<P>そこで SJIS の場合には正規表現でエラーにならないように，次のようにパターンの部分を <NOBR><CODE>\Q</CODE></NOBR> と<NOBR><CODE>\E</CODE></NOBR> で挟んでエスケープするという回避方法があります．<BLOCKQUOTE><PRE>$str = &quot;このTESTで充分&quot;;$str =~ s/\QこのTESTで充分\E/このテストで十分/;  # これで SJIS でも大丈夫？print $str, &quot;\n&quot;;</PRE></BLOCKQUOTE>ところが，これを実際に実行してみると<FONT COLOR="Blue">文字化け</FONT>してしまいます．なぜなら，SJIS の「十」の文字コードは <NOBR>0x8F 0x5C</NOBR>であり，<NOBR>0x5C</NOBR> というのは ASCII の <CODE>\</CODE>の文字コードであるため，「分」の <NOBR>1バイト目</NOBR>と合わせて特別な意味として解釈しようとするためです．<CODE>\</CODE> と「分」の<NOBR>1バイト目</NOBR>を合わせたエスケープシーケンスというものはありませんので，結果的に「十」の <NOBR>2バイト目</NOBR>の <CODE>\</CODE>は無視されることになります．<P>このように SJIS には <NOBR>2バイト目</NOBR>が <CODE>\</CODE> である文字があるために文字化けしてしまいます．同様に，<NOBR>2バイト目</NOBR>が<CODE>@</CODE> である文字では配列と解釈されてしまうことがあります．<NOBR>2バイト目</NOBR>が <CODE>\</CODE> である文字については，その後ろに<CODE>\</CODE> を書けば回避することができますが，<NOBR>2バイト目</NOBR>が<CODE>@</CODE>である文字についてはさらに別の回避手段を取らざるを得なくなります．ちなみに，SJIS で <NOBR>2バイト目</NOBR>が <CODE>\</CODE> である文字は「―ソЫ噂浬欺圭構蚕十申曾箪貼能表暴予禄兔喀媾彌拿杤歃濬畚秉綵臀藹觸軆鐔饅鷭」です．また，<NOBR>2バイト目</NOBR>が <CODE>@</CODE> である文字は全角スペースと「ァА院魁機掘后察宗拭繊叩邸如鼻法諭蓮僉咫奸廖戞曄檗漾瓠磧紂隋蕁襦蹇錙顱鵝」です．これらの文字以外にも SJIS では問題となる文字がまだまだあります．<P>なお，さきほど SJIS の場合に <NOBR><CODE>\Q</CODE></NOBR> と<NOBR><CODE>\E</CODE></NOBR> で挟んでエスケープするという回避方法について触れましたが，実は<FONT COLOR="Red">この方法は完全ではありません</FONT>．たとえば，次のスクリプトを見てください．<BLOCKQUOTE><PRE>if ($str =~ /\Q$keyword\E/) {  print &quot;マッチした\n&quot;;}</PRE></BLOCKQUOTE><P>このスクリプトのように，ある<NOBR>キーワード <CODE>$keyword</CODE></NOBR>を <NOBR><CODE>\Q</CODE></NOBR> と <NOBR><CODE>\E</CODE></NOBR>で挟めばエラーにならずにうまくパターンマッチできるという話があります．たしかにエラーにはなりませんが，たとえば SJIS で<NOBR><CODE>$str = 'テスト';</CODE></NOBR>のときに <NOBR><CODE>$keyword = 'X';</CODE></NOBR> でパターンマッチを行なうとマッチしてしまいます．これは SJIS の「ス」の文字コードが<NOBR>0x83 0x58</NOBR> であり，0x58 というのが ASCII の X の文字コードであるためです．また， <NOBR><CODE>$str = 'ｃａ＜ｂ';</CODE></NOBR> のときに<NOBR><CODE>$keyword = 'モ＝モ';</CODE></NOBR> のときもマッチしてしまいます．これは「ｃａ＜ｂ」という文字列の文字コード<NOBR>0x82 0x83 0x82 0x81 0x81 0x83 0x82 0x82</NOBR> に対して，<FONT COLOR="Red"><NOBR>1バイト</NOBR>ずつずれた位置</FONT>で「モ＝モ」という文字列の文字コード<NOBR>0x83 0x82 0x81 0x81 0x83 0x82</NOBR> がマッチしてしまうからです．<P>perl で日本語を扱うための手段の 1つが jperl を使うということです．jperl はオリジナルの perl にパッチをあてて，日本語を扱えるようにしたものです．Windows用の jperl は以下の場所(鈴木 紀夫さん提供)から入手することができます．<BLOCKQUOTE><A HREF="http://www.shonanblue.ne.jp/~kipp/perl/jperl/index.html">  <NOBR>http://www.shonanblue.ne.jp/~kipp/perl/jperl/index.html</NOBR></A></BLOCKQUOTE><P>それでは最初のスクリプトを <NOBR>EUC-JP</NOBR>で書いた場合はどうでしょうか．<NOBR>EUC-JP</NOBR>で書いた場合には正常に実行できるはずです．なぜなら，<NOBR>EUC-JP</NOBR>には JIS や SJIS のように perl が特別な意味として解釈してしまうような文字が含まれていないからです．perl で日本語を扱うには<FONT COLOR="Red">perl スクリプトを <NOBR>EUC-JP</NOBR>で書く</FONT>のが一番簡単な方法です．以下では，<NOBR>EUC-JP</NOBR>でスクリプトを書くことを前提としています．<P>実は <NOBR>EUC-JP</NOBR> のパターンマッチにおいても SJIS と同じように間違ってマッチしてしまう場合があります．このことについては「<A HREF="#JP_Match">正しくパターンマッチさせる</A>」を参照してください．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="JP_Trans"><HR></A><H3>漢字コードを <NOBR>EUC-JP</NOBR> に変換して処理する</H3><BLOCKQUOTE><P>perl スクリプトは <NOBR>EUC-JP</NOBR> で書いたとしても，入力した日本語の漢字コードがSJIS や JIS では正常な動作を期待することはできません．そこで何らかの処理を行なうときには一度 EUC-JP に変換してから行ないます．perl スクリプトを<NOBR>EUC-JP</NOBR> で書き，<FONT COLOR="Red">漢字コードが <NOBR>EUC-JP</NOBR> である日本語を処理する</FONT>というのが，perl で日本語を扱うときに一番問題が起きにくい方法です．<P>入力した日本語の漢字コードが <NOBR>EUC-JP</NOBR> ではない場合，または，漢字コードがわからない場合には，漢字コードを<A HREF="#jcode.pl"><NOBR><TT>jcode.pl</TT></NOBR></A>(歌代 和正さん作)を使って <NOBR>EUC-JP</NOBR> に変換してあげます．<NOBR><CODE>$str</CODE></NOBR> を <NOBR>EUC-JP</NOBR>に変換するには次のように書きます．<BLOCKQUOTE><B><PRE># $str を EUC-JP に変換するrequire 'jcode.pl';jcode::convert(\$str, 'euc');</PRE></B></BLOCKQUOTE><P><NOBR><CODE>'euc'</CODE></NOBR> の部分を<NOBR><CODE>'sjis'</CODE></NOBR> や <NOBR><CODE>'jis'</CODE></NOBR> にすれば，SJIS や JIS に変換できます．もし，入力した日本語の漢字コードが<NOBR><CODE>$code</CODE></NOBR> であるとわかっている場合には，次のように明示的に指定することで内部で自動判別しないようにすることができます．<BLOCKQUOTE><B><PRE># 漢字コードが $code である $str を EUC-JP に変換するrequire 'jcode.pl';jcode::convert(\$str, 'euc', $code);</PRE></B></BLOCKQUOTE><P>「<A HREF="#JP_Code">漢字コードを調べる</A>」で自動判別の判定精度を上げて求めた <NOBR><CODE>$code</CODE></NOBR> を使いたいときにもこの書式を使います．<P>余談ですが，次のように <FONT COLOR="Blue"><NOBR><CODE>my</CODE>宣言</NOBR></FONT>された変数に対して，<FONT COLOR="Blue">型グロブ</FONT>を使って変換しようとするのは<FONT COLOR="Red">間違い</FONT>です．<BLOCKQUOTE><PRE># my 宣言された変数を変換するときの間違った例require 'jcode.pl';my $str = 'my 宣言された変数の型グロブはない';jcode::convert(*str, 'euc');</PRE></BLOCKQUOTE><NOBR><CODE>my</CODE> 宣言</NOBR>された変数の型グロブはないので，これでは変換することはできません． <NOBR><CODE>my</CODE> 宣言</NOBR>された変数のハードリファレンスは求めることができるので，最初のスクリプトのように常に <NOBR><CODE>\$str</CODE></NOBR> のように書くのが一番問題の起きにくい書き方です．<A NAME="jcode.pl"><HR></A><P><NOBR><TT>jcode.pl</TT></NOBR>は以下の場所に最新バージョンが置いてあります．<BLOCKQUOTE><A HREF="http://www.srekcah.org/jcode/">http://www.srekcah.org/jcode/</A></BLOCKQUOTE>現在の最新バージョンは <NOBR><TT>jcode.pl-2.13</TT></NOBR> です．これを取ってきて <NOBR><TT>jcode.pl</TT></NOBR> に名前を変更して使います．<NOBR><TT>jcode.pl</TT></NOBR> の使い方は<NOBR><TT>jcode.pl</TT></NOBR> の中に書かれています．よくわからなければ，小塚 敦さんによる「<A HREF="http://www.mikeneko.ne.jp/~lab/kcode/jcode.html">jcode.plの私的な解説書</A>」を読むといいかもしれません．<P><A HREF="http://openlab.ring.gr.jp/Jcode/index-j.html">Jcode.pm - jcode.pl の後継</A>(小飼 弾さん作)というものも公開されています．<NOBR><TT>Jcode.pm</TT></NOBR> は UNICODE に対応していますが，使用するには<NOBR><TT>jcode.pl</TT></NOBR> のようにコピーするだけでは駄目で，ちゃんとインストールする必要があります．なお，<NOBR>Windows用</NOBR>の perl である<A HREF="http://www.activestate.com/Products/ActivePerl/index.html">ActivePerl</A> 5.6用に，コンパイル済みのパッケージが以下の場所(鈴木 紀夫さん提供)で配布されています．<BLOCKQUOTE><A HREF="http://www.shonanblue.ne.jp/~kipp/perl/packages/5.6/index.html">http://www.shonanblue.ne.jp/~kipp/perl/packages/5.6/index.html</A></BLOCKQUOTE><P><NOBR>バージョン 2.10</NOBR>以前の <NOBR><TT>jcode.pl</TT></NOBR>はスレッドが有効になっている perlでは<FONT COLOR="Red">使用することができません</FONT>．スレッドが有効になっている perl では<NOBR>特殊変数<CODE>$_</CODE></NOBR> や <NOBR><CODE>@_</CODE></NOBR>は<FONT COLOR="Blue">レキシカル変数</FONT>となります．レキシカル変数とは<FONT COLOR="Blue"><NOBR><CODE>my</CODE>宣言</NOBR></FONT>された変数のことです．このレキシカル変数というのは<FONT COLOR="Blue"><NOBR><CODE>local</CODE> 宣言</NOBR></FONT>することができないのですが，<NOBR>バージョン 2.10</NOBR>以前の<NOBR><TT>jcode.pl</TT></NOBR> では関数の引数を<NOBR><CODE>local</CODE> 宣言</NOBR>した<NOBR>型グロブ <CODE>*_</CODE></NOBR>に代入しようとしているために正常に動作しません．最新バージョンの<NOBR><TT>jcode.pl</TT></NOBR> 及び <NOBR><TT>Jcode.pm</TT></NOBR>はスレッドが有効になっている perl でも正常に動作します．<P>手元の perl のスレッドが有効になっているかどうかを調べるには<NOBR><TT>perl -V</TT></NOBR> と入力し実行します．このとき<NOBR><TT>usethreads=undef</TT></NOBR> となっていれば無効になっているので<NOBR><TT>jcode.pl</TT></NOBR> を安心して使うことができます．<NOBR>perl5.005</NOBR>より前の perl もスレッド機能がないので問題ありません．もし，スレッドが有効になっていた場合には<NOBR>バージョン 2.10</NOBR>以前の<NOBR><TT>jcode.pl</TT></NOBR> が使えないことはもちろんのこと，<NOBR>特殊変数 <CODE>$_</CODE></NOBR> や<NOBR><CODE>@_</CODE></NOBR>がレキシカル変数になっていることにも注意してスクリプトを書く必要があります．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="JP_Code"><HR></A><H3>漢字コードを調べる</H3><BLOCKQUOTE><BLOCKQUOTE><B><PRE># $str の漢字コードを調べるrequire 'jcode.pl';($match, $code) = jcode::getcode(\$str);$code = 'euc' if $code eq undef and $match &gt; 0;</PRE></B></BLOCKQUOTE><A HREF="#jcode.pl"><NOBR><TT>jcode.pl</TT></NOBR></A> の<NOBR><CODE>getcode</CODE> 関数</NOBR>を使います．<NOBR><CODE>$code</CODE></NOBR> には <NOBR><CODE>'euc'</CODE></NOBR> や<NOBR><CODE>'sjis'</CODE></NOBR>，<NOBR><CODE>'jis'</CODE></NOBR>といった文字列が入っています．詳しくは jcode.pl の中の説明を読んでください．<P>ここで注意が必要なのは，<FONT COLOR="Red">漢字コードを正確に調べることには限界がある</FONT>ということです．SJIS の漢字(第二水準)の一部やSJIS の半角カタカナ <NOBR>2文字</NOBR>は <NOBR>EUC-JP</NOBR> の漢字<NOBR>1文字</NOBR>と区別がつきません．もし，漢字コードが<FONT COLOR="Red"><NOBR>EUC-JP</NOBR>か SJIS の両方の可能性があり，どちらか判断できないときには<NOBR><CODE>jcode::getcode()</CODE></NOBR> は <CODE>undef</CODE>を返します</FONT>．ただ，厳密にはどちらか判断できないとは言え，半角カタカナが含まれていない場合にはほとんどの場合 <NOBR>EUC-JP</NOBR> であるので，上のスクリプトでは最終的に<CODE>undef</CODE> ではなく <NOBR>EUC-JP</NOBR> としています．<P><NOBR><CODE>jcode::getcode()</CODE></NOBR> は SJISの半角カタカナを考慮せずに判定しています．このため，SJIS だと判断できる半角カタカナが含まれている文字列でも <NOBR>EUC-JP</NOBR> と間違ってしまうことがあります．そこで，次のように書くことで判定精度を上げることができます．<BLOCKQUOTE><B><PRE># $str の漢字コードを調べるrequire 'jcode.pl';($match, $code) = jcode::getcode(\$str);$code = 'euc' if $code eq undef and $match &gt; 0;$ascii = '[\x00-\x7F]';if ($code eq 'euc') {  if ($str !~ /^(?:$jcode::re_euc_c|$jcode::re_euc_kana|                   $jcode::re_euc_0212|$ascii)*$/ox) {    if ($str =~ /^(?:$jcode::re_sjis_c|$jcode::re_sjis_kana|$ascii)*$/o) {      $code = 'sjis';    }  }}</PRE></B></BLOCKQUOTE>これで SJIS を <NOBR>EUC-JP</NOBR> と間違って判定する可能性を減らすことができますが，その分処理に時間がかかってしまうことを忘れてはいけません．このようにして自動判定の判定精度を上げて求めた <NOBR><CODE>$code</CODE></NOBR>は漢字コードを変換するときにも利用することができます．漢字コードの変換に関しては「<A HREF="#JP_Trans">漢字コードを <NOBR>EUC-JP</NOBR>に変換して処理する</A>」を参照．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="JP_Exist"><HR></A><H3>全角文字が含まれているか判定する</H3><BLOCKQUOTE><P><NOBR><CODE>$str</CODE></NOBR> は<FONT COLOR="Blue"><NOBR>EUC-JP</NOBR> という前提</FONT>ですので，必要ならばあらかじめ <NOBR>EUC-JP</NOBR> に変換しておいてください．漢字コードの変換に関しては「<A HREF="#JP_Trans">漢字コードを <NOBR>EUC-JP</NOBR>に変換して処理する</A>」を参照．<BLOCKQUOTE><B><PRE># $str に全角文字(半角カタカナを含まない)が含まれているか判定するif ($str =~ /[\xA1-\xFE][\xA1-\xFE]/) {  print &quot;含まれている\n&quot;;}</PRE></B></BLOCKQUOTE>全角文字は <NOBR>JIS X 0208</NOBR> と <NOBR>JIS X 0212</NOBR> なので，半角カタカナである <NOBR>JIS X 0201片仮名</NOBR> は含みません．全角文字が含まれているかどうかを判定するには，<NOBR>JIS X 0208</NOBR> と<NOBR>JIS X 0212</NOBR> の共通部分であり，ASCII や<NOBR>JIS X 0201片仮名</NOBR> では現れないパターン<NOBR><CODE>/[\xA1-\xFE][\xA1-\xFE]/</CODE></NOBR> を使って判定します．<BLOCKQUOTE><B><PRE># $str に半角カタカナが含まれているか判定するif ($str =~ /\x8E/) {  print &quot;含まれている\n&quot;;}</PRE></B></BLOCKQUOTE><P>半角カタカナが含まれているかどうかを判定するには，<NOBR>EUC-JP</NOBR> では<NOBR><CODE>/\x8E/</CODE></NOBR> を調べるだけでできます．<BLOCKQUOTE><B><PRE># $str に ASCII 以外が含まれているか判定するif ($str =~ /[\x8E\xA1-\xFE]/) {  print &quot;含まれている\n&quot;;}</PRE></B></BLOCKQUOTE><P>ASCII 以外の文字が含まれているかを判定するには，<NOBR><CODE>/[\x8E\xA1-\xFE]/</CODE></NOBR> を調べることでできます．<NOBR><CODE>\x8E</CODE></NOBR> があれば<NOBR>JIS X 0201片仮名</NOBR> の <NOBR>1バイト目</NOBR>でマッチし，<NOBR><CODE>[\xA1-\xFE]</CODE></NOBR> があれば<NOBR>JIS X 0208</NOBR> の <NOBR>1バイト目</NOBR>か，<NOBR>JIS X 0212</NOBR> の <NOBR>2バイト目</NOBR>でマッチしますので，ASCII 以外の文字が含まれていることがわかります．<P><NOBR><CODE>$str</CODE></NOBR> が <NOBR>EUC-JP</NOBR> かどうかもわからないときは <A HREF="#jcode.pl"><NOBR><TT>jcode.pl</TT></NOBR></A>を使って調べることもできます．<NOBR><TT>jcode.pl</TT></NOBR> を使って「<A HREF="#JP_Code">漢字コードを調べる</A>」で書いたスクリプトで<NOBR><CODE>$str</CODE></NOBR> の漢字コードを調べた結果が <CODE>undef</CODE>の場合は ASCII 以外の文字は含まれていないとすることができます．逆に言えば，<CODE>undef</CODE> ではない場合は ASCII 以外の文字が含まれているとすることができます．このとき，次のように慌てて<NOBR><CODE>$match</CODE></NOBR> を使わずに，いきなり <CODE>undef</CODE>かどうかを調べる方法は<FONT COLOR="Red">間違っています</FONT>．<BLOCKQUOTE><PRE># $str に ASCII 以外が含まれているか判定するときの間違った例require 'jcode.pl';$code = jcode::getcode(\$str);if ($code eq undef) {  print &quot;ASCII以外は含まれていない\n&quot;;  print &quot;この判断は間違い\n&quot;;}</PRE></BLOCKQUOTE><NOBR><CODE>jcode::getcode()</CODE></NOBR> は<FONT COLOR="Red"><NOBR>EUC-JP</NOBR> か SJISの両方の可能性があり，どちらか判断できないときにも <CODE>undef</CODE>を返します</FONT>．「<A HREF="#JP_Code">漢字コードを調べる</A>」で書いてあるように <NOBR><CODE>$match</CODE></NOBR> を使って <CODE>undef</CODE>の場合を処理する必要があります．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="JP_Cut"><HR></A><H3>文字が途切れているか判定する</H3><BLOCKQUOTE><P><NOBR><CODE>$str</CODE></NOBR> は<FONT COLOR="Blue"><NOBR>EUC-JP</NOBR> という前提</FONT>ですので，必要ならばあらかじめ <NOBR>EUC-JP</NOBR> に変換しておいてください．漢字コードの変換に関しては「<A HREF="#JP_Trans">漢字コードを <NOBR>EUC-JP</NOBR>に変換して処理する</A>」を参照．<BLOCKQUOTE><B><PRE># $str の最後の文字が途切れているか判定するif ($str =~ /\x8F$/ or $str =~ tr/\x8E\xA1-\xFE// % 2) {  print &quot;最後の文字が途切れている\n&quot;;}</PRE></B></BLOCKQUOTE><P><NOBR>EUC-JP</NOBR> で文字が途切れる可能性があるのは，<NOBR>JIS X0201片仮名</NOBR>(半角カタカナ)と<NOBR>JIS X 0208</NOBR>(全角文字)と<NOBR>JIS X 0212</NOBR>(補助漢字)です．<NOBR>JIS X 0212</NOBR> は <NOBR>3バイト</NOBR>で表わされ，最初が<NOBR><CODE>\x8F</CODE></NOBR> で始まります．最初の条件は<NOBR><CODE>$str</CODE></NOBR> が <NOBR><CODE>\x8F</CODE></NOBR>で終わっていた場合，すなわち，<NOBR>JIS X 0212</NOBR> が <NOBR>1バイト目</NOBR>で途切れていた場合を表わしています．次の条件が <NOBR>JIS X 0201片仮名</NOBR> と <NOBR>JIS X 0208</NOBR> が<NOBR>1バイト目</NOBR>で途切れていた場合と，<NOBR>JIS X 0212</NOBR> が<NOBR>2バイト目</NOBR>で途切れていた場合です．<NOBR><CODE>tr/\x8E\xA1-\xFE//</CODE></NOBR> は <NOBR><CODE>$str</CODE></NOBR>の中の，<NOBR>JIS X 0201片仮名</NOBR> と <NOBR>JIS X 0208</NOBR> の<NOBR>1バイト目</NOBR>と <NOBR>2バイト目</NOBR>，<NOBR>JIS X 0212</NOBR> の <NOBR>2バイト目</NOBR>と<NOBR>3バイト目</NOBR>の数を数えています．この数がもし奇数ならば文字が途切れていることがわかります．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="JP_Z2H"><HR></A><H3>全角英数字を半角英数字に変換する</H3><BLOCKQUOTE><P><NOBR><CODE>$str</CODE></NOBR> は<FONT COLOR="Blue"><NOBR>EUC-JP</NOBR> という前提</FONT>ですので，必要ならばあらかじめ <NOBR>EUC-JP</NOBR> に変換しておいてください．漢字コードの変換に関しては「<A HREF="#JP_Trans">漢字コードを <NOBR>EUC-JP</NOBR>に変換して処理する</A>」を参照．<BLOCKQUOTE><B><PRE># $str の全角英数字を半角英数字に変換するrequire 'jcode.pl';jcode::tr(\$str, '０-９Ａ-Ｚａ-ｚ', '0-9A-Za-z');</PRE></B></BLOCKQUOTE><P><A HREF="#jcode.pl"><NOBR><TT>jcode.pl</TT></NOBR></A> の <NOBR><CODE>tr</CODE> 関数</NOBR>を使います．この関数は全角文字に対応した<CODE>tr</CODE> です．詳しくは <NOBR><TT>jcode.pl</TT></NOBR> の中の説明を読んでください．基本的に <CODE>tr</CODE>なので，全角英数字以外にも全角スペースを半角スペースにするなどの変換も次のように書くことで簡単にできます．<BLOCKQUOTE><B><PRE># $str の全角スペースなどを半角スペースなどに変換するrequire 'jcode.pl';jcode::tr(\$str, '　（）＿＠−', ' ()_@-');</PRE></B></BLOCKQUOTE><P>逆に，<NOBR>第 1引数</NOBR>と<NOBR>第 2引数</NOBR>を逆にすれば，半角文字を全角文字にすることもできます．半角カタカナと全角カタカナの相互変換に関しては「<A HREF="#JP_HK2ZK">半角カタカナを全角カタカナに変換する</A>」を参照．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="JP_HK2ZK"><HR></A><H3>半角カタカナを全角カタカナに変換する</H3><BLOCKQUOTE><P><NOBR><CODE>$str</CODE></NOBR> は<FONT COLOR="Blue"><NOBR>EUC-JP</NOBR> という前提</FONT>ですので，必要ならばあらかじめ <NOBR>EUC-JP</NOBR> に変換しておいてください．漢字コードの変換に関しては「<A HREF="#JP_Trans">漢字コードを <NOBR>EUC-JP</NOBR>に変換して処理する</A>」を参照．<BLOCKQUOTE><B><PRE># $str の半角カタカナを全角カタカナに変換するrequire 'jcode.pl';jcode::h2z_euc(\$str);</PRE></B></BLOCKQUOTE><P><A HREF="#jcode.pl"><NOBR><TT>jcode.pl</TT></NOBR></A> の <NOBR><CODE>h2z_euc</CODE> 関数</NOBR>を使います．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="JP_Match"><HR></A><H3>正しくパターンマッチさせる</H3><BLOCKQUOTE><P><NOBR><CODE>$str</CODE></NOBR> および <NOBR><CODE>$pattern</CODE></NOBR> は<FONT COLOR="Blue"><NOBR>EUC-JP</NOBR> という前提</FONT>ですので，必要ならばあらかじめ <NOBR>EUC-JP</NOBR> に変換しておいてください．漢字コードの変換に関しては「<A HREF="#JP_Trans">漢字コードを <NOBR>EUC-JP</NOBR>に変換して処理する</A>」を参照．<P>perl で日本語を扱う場合にはスクリプトを <NOBR>EUC-JP</NOBR> で書き，漢字コードが <NOBR>EUC-JP</NOBR> である日本語を処理するというのが一番問題が起きにくい方法であるということを「<A HREF="#JP_EUC_JP">perl スクリプトは <NOBR>EUC-JP</NOBR> で書く</A>」と「<A HREF="#JP_Trans">漢字コードを <NOBR>EUC-JP</NOBR>に変換して処理する</A>」で述べました．しかし，それだけでは少し困ったことが起きることがあります．たとえば，次のようなスクリプトを実行すると間違ってマッチしてしまいます．<BLOCKQUOTE><PRE># 間違ってマッチしてしまう例$str = 'これはテストです';$pattern = '好';if ($str =~ /$pattern/) {  print &quot;マッチした\n&quot;;}</PRE></BLOCKQUOTE><P>なぜこのようなことが起きてしまうのかというと，<NOBR>EUC-JP</NOBR>の「ス」の文字コードは <NOBR><TT>0xA5 <FONT COLOR="Blue">0xB9</FONT></TT></NOBR>，「ト」は <NOBR><TT><FONT COLOR="Blue">0xA5</FONT>0xC8</TT></NOBR>，「好」は <NOBR><TT><FONT COLOR="Blue">0xB9 0xA5</FONT></TT></NOBR>であり，ちょうど「スト」の真ん中の部分が「好」と同じになるのでマッチしてしまうのです．このように<FONT COLOR="Blue">ずれた場所でマッチ</FONT>してしまっては困る場合には次のように書きます．<BLOCKQUOTE><B><PRE># $str に $pattern を正しくマッチさせる$ascii = '[\x00-\x7F]';$twoBytes = '[\x8E\xA1-\xFE][\xA1-\xFE]';$threeBytes = '\x8F[\xA1-\xFE][\xA1-\xFE]';if ($str =~ /^(?:$ascii|$twoBytes|$threeBytes)*?(?:$pattern)/) {  print &quot;マッチした\n&quot;;}</PRE></B></BLOCKQUOTE><P>なぜこのような書き方になるのか説明します．最初の間違ってマッチしてしまうスクリプトでは <NOBR><CODE>/$pattern/</CODE></NOBR> というように無造作にマッチさせようとしたためにずれた場所でマッチしてしまいました．そこで，ずれた場所でマッチしないようにするには，<NOBR><CODE>$pattern</CODE></NOBR> の前には日本語の文字が何文字かあって，その後に <NOBR><CODE>$pattern</CODE></NOBR> がくるということを明示的に書いてあげる必要があります．<NOBR>EUC-JP</NOBR> での<NOBR>1文字</NOBR>というのは <NOBR>1バイト文字</NOBR>である ASCII，<NOBR>2バイト文字</NOBR>である <NOBR>JIS X 0201片仮名</NOBR>(半角カタカナ)と <NOBR>JIS X 0208</NOBR>(全角文字)，<NOBR>3バイト文字</NOBR>である <NOBR>JIS X 0212</NOBR>(補助漢字)のことです．これを正規表現で表わしたのが <NOBR><CODE>(?:$ascii|$twoBytes|$threeBytes)</CODE></NOBR>の部分です．この文字が文字列の先頭から何文字か続いた後に<NOBR><CODE>$pattern</CODE></NOBR> がくるということを正規表現で書いたのが上のスクリプトです．<P>正規表現で任意の一文字を表わすには普通<NOBR><CODE>.</CODE>(ピリオド)</NOBR>を使いますが，日本語の文字列に対するマッチングでは，<NOBR><CODE>.</CODE>(ピリオド)</NOBR> で書きたくなる場所を<NOBR><CODE>(?:$ascii|$twoBytes|$threeBytes)</CODE></NOBR> とすればいいことになります．最初のスクリプトの <NOBR><CODE>/$pattern/</CODE></NOBR> も<NOBR><CODE>/^.*?(?:$pattern)/</CODE></NOBR> だと思えば上のスクリプトのようになるのも納得していただけるのではないでしょうか．<P>日本語の文字列に対して正しくマッチさせる方法として，これまで書いてきたように <NOBR>EUC-JP</NOBR> での <NOBR>1文字</NOBR>というものをちゃんと意識して正規表現を書くという方法以外に，あらかじめマッチさせる前に <NOBR>2バイト文字</NOBR>と <NOBR>3バイト文字</NOBR>の後ろに文字の区切りがわかるように<FONT COLOR="Blue">区切り文字をつけておく</FONT>という方法があります．具体的には次のように，マッチの対象となっている日本語の文字列<NOBR><CODE>$str</CODE></NOBR> と，マッチさせようとしているパターン<NOBR><CODE>$pattern</CODE></NOBR> の両方に区切り文字をつける処理をしてからマッチングを行ないます．このスクリプトでは区切り文字として<NOBR><CODE>\000</CODE></NOBR> を使っています．<BLOCKQUOTE><PRE># 区切り文字をつけて正しくマッチさせる(非常に遅い)$twoBytes = '[\x8E\xA1-\xFE][\xA1-\xFE]';$threeBytes = '\x8F[\xA1-\xFE][\xA1-\xFE]';$pattern =~ s/($twoBytes|$threeBytes)/$1\000/og;$str =~ s/($twoBytes|$threeBytes)/$1\000/og;if ($str =~ /$pattern/) {  print &quot;マッチした\n&quot;;}</PRE></BLOCKQUOTE><P>この方法ではマッチさせる前に区切り文字をつける処理を行なうことで，正規表現そのものは普通に書くことができます．この方法はわかりやすいところはいいのですが，おそらくほとんどの場合区切り文字を使わない最初のスクリプトよりも<FONT COLOR="Red">実行速度が遅い</FONT>でしょう．<P>この <NOBR>2つ</NOBR>方法の特徴を考えてみます．区切り文字を使わない方法は，前処理なしにすぐにパターンマッチを始めることができる．しかし，パターンマッチそのものは正規表現が複雑なため少し遅い．区切り文字を使った方法は，あらかじめ文字列全体に対し区切り文字を入れる前処理を行なう必要がある．ただ，パターンマッチそのものは正規表現が複雑にならないために速い．<P>それでは実際に比較したらどうなるか調べてみました．パターンマッチが成功しなかった場合，文字列全体に対し検索を行なうことになりますが，私がベンチマークをとってみたところ，区切り文字を使わない方法の方が<FONT COLOR="Red">圧倒的に速かった</FONT>(<NOBR>約 15倍</NOBR>) です．パターンマッチが成功する場合には，文字列の途中で検索を止めることができるので，文字列全体に対して必ず前処理を行なわなければならない区切り文字を使った方法の方が遅いことは言うまでもありません．結局，区切り文字を使わない方法は正規表現が複雑になった分パターンマッチそのものは少し遅くなりますが，区切り文字を使う方法の方は，いかんせん区切り文字を入れる処理が遅すぎてパターンマッチそのものの速さが全然活きなかったようです．<P>この結果からすると，データの中からマッチするものだけ取り出すような処理には明らかに区切り文字を使わない最初のスクリプトの方がいいと言えます．区切り文字を使った方法の方がいい場合としては，前処理の遅さをパターンマッチの速さで補えるほど何度も同じ文字列に対してパターンマッチを行なう場合です．もちろん，これら実行速度に関しては環境に依存する話ですので，実際に自分の環境で試してみるのがいいでしょう．<P>次に，日本語の文字列を正しく置換する方法について説明します．次のようなスクリプトが間違って置換してしまうということはすでに説明したとおりです．<BLOCKQUOTE><PRE># 間違って置換してしまう例$str = 'これはテストです';$pattern = '好';$replace = '嫌';$str =~ s/$pattern/$replace/g;</PRE></BLOCKQUOTE><P>次のように書くことで正しく置換することができます．<BLOCKQUOTE><B><PRE># $str の $pattern を $replace に正しく置換する$ascii = '[\x00-\x7F]';$twoBytes = '[\x8E\xA1-\xFE][\xA1-\xFE]';$threeBytes = '\x8F[\xA1-\xFE][\xA1-\xFE]';$str =~ s/\G((?:$ascii|$twoBytes|$threeBytes)*?)(?:$pattern)/$1$replace/g;</PRE></B></BLOCKQUOTE><P>このスクリプトの基本的な考え方は，<NOBR>EUC-JP</NOBR> での<NOBR>1文字</NOBR>というものをちゃんと意識して正規表現を書くマッチの方法と同じです．ただ，マッチさせるだけの場合と違うのは<FONT COLOR="Red"><NOBR><CODE>$1</CODE></NOBR></FONT> と<FONT COLOR="Red"><NOBR><CODE>\G</CODE></NOBR></FONT> を使っているところです．<NOBR><CODE>$1</CODE></NOBR> を使うのは，置換する部分をマッチさせるときに<NOBR><CODE>$pattern</CODE></NOBR> の前にある文字もいっしょにマッチさせることになるため，この部分を置換せずにそのまま残してあげる必要があるからです．そこで <NOBR><CODE>$pattern</CODE></NOBR> の前の部分に当たる正規表現<NOBR><CODE>(?:$ascii|$twoBytes|$threeBytes)*?</CODE></NOBR> を括弧で囲って<NOBR><CODE>$1</CODE></NOBR> で参照できるようにしています．<P>次に <NOBR><CODE>\G</CODE></NOBR> の説明をします．<NOBR><CODE>\G</CODE></NOBR>を使うのは<FONT COLOR="Blue"><NOBR>修飾子 <CODE>g</CODE></NOBR></FONT>がつけられているためです．<NOBR>修飾子 <CODE>g</CODE></NOBR> は，マッチするかどうか判定するだけならば必要ないですし，また，<NOBR>1回</NOBR>しか置換しない場合も必要ありません．そのときは<NOBR>修飾子 <CODE>g</CODE></NOBR> をつけるのをやめて，<NOBR><CODE>\G</CODE></NOBR> を文字列の先頭にマッチする <CODE>^</CODE>に変えることができます．逆に言えば，<NOBR>修飾子 <CODE>g</CODE></NOBR> をつけて<NOBR><CODE>$str</CODE></NOBR> の中の <NOBR><CODE>$pattern</CODE></NOBR>をすべて置換したいときに，文字列の先頭にだけマッチする<CODE>^</CODE> を使うことができないということです．<NOBR><CODE>\G</CODE></NOBR>は<NOBR>修飾子 <CODE>g</CODE></NOBR> がつけられているときに，<FONT COLOR="Red">パターンマッチの開始位置にマッチ</FONT>します．つまり，<NOBR><CODE>\G</CODE></NOBR> は一番最初は <CODE>^</CODE> と同じで，次からは<NOBR><CODE>$pattern</CODE></NOBR> のすぐ後ろでマッチします．わかりやすく簡単に言うと，<NOBR><CODE>\G</CODE></NOBR> はマッチするかどうかこれから調べようとしている残りの部分の先頭にマッチすると言えます．<NOBR><CODE>\G</CODE></NOBR>を使うことで，ずれた位置で <NOBR><CODE>$pattern</CODE></NOBR>がマッチすることがないようになります．<P>置換の場合にも次のように区切り文字をつけて正しく置換する方法があります．<BLOCKQUOTE><PRE># 区切り文字をつけて正しく置換させる(非常に遅い)$twoBytes = '[\x8E\xA1-\xFE][\xA1-\xFE]';$threeBytes = '\x8F[\xA1-\xFE][\xA1-\xFE]';$pattern =~ s/($twoBytes|$threeBytes)/$1\000/og;$str =~ s/($twoBytes|$threeBytes)/$1\000/og;$str =~ s/$pattern/$replace/g;$str =~ tr/\000//d;# $str =~ s/($twoBytes|$threeBytes)\000/$1/og;</PRE></BLOCKQUOTE><P>基本的に区切り文字をつけて正しくマッチさせる方法と同じです．ただ，マッチさせるだけの場合と違って，置換後に区切り文字を削除する必要があります．このスクリプトでは区切り文字に <NOBR><CODE>\000</CODE></NOBR> を使っていて，置換後にこの区切り文字を <CODE>tr</CODE> を使って削除しています．ところが，<NOBR><CODE>$str</CODE></NOBR> の中に初めから含まれていた<NOBR><CODE>\000</CODE></NOBR> もいっしょに削除してしまいます．<CODE>tr</CODE> を使って削除できるのは<NOBR><CODE>$str</CODE></NOBR> の中に区切り文字と同じ<NOBR><CODE>\000</CODE></NOBR> が含まれていないという前提が必要です．もし，<NOBR><CODE>$str</CODE></NOBR> の中に <NOBR><CODE>\000</CODE></NOBR> が含まれているかもしれない場合には <CODE>tr</CODE>を使って区切り文字を削除するのを止めて，<NOBR><CODE>$str =~ tr/\000//d;</CODE></NOBR> を<NOBR><CODE>$str =~ s/($twoBytes|$threeBytes)\000/$1/og;</CODE></NOBR>に変更します．<P>実行速度について <NOBR>2つ</NOBR>の方法を比較してみました．与えた文字列に対して全く置換するところがなかった場合には，区切り文字を使わない方法の方が<FONT COLOR="Red">圧倒的に速かった</FONT>(<NOBR>約 35倍</NOBR>) です．全部の文字を置換する必要がある文字列を与えた場合でも，区切り文字を使わない方法の方が<FONT COLOR="Blue">4割程度速かった</FONT>です．もし，区切り文字を使う場合の方法で後処理に<CODE>tr</CODE> を使わなかった場合には更にスピード差が出るでしょう．結局，置換の場合でも区切り文字を使う場合は，前処理と後処理に時間がかかりすぎるということが言えます．実行速度に関しては環境に依存する話なので，どちらが速いか自分の環境で試してみるのが一番だということは言うまでもありません．<P>さて，ここまでの話では <NOBR><CODE>$pattern</CODE></NOBR> は Perl の文法的に正しい正規表現という前提でした．ですから，たとえば<NOBR>開き括弧 <CODE>(</CODE></NOBR> にマッチさせたい場合には<NOBR><CODE>\(</CODE></NOBR> というようにエスケープする必要があります．CGIなどにおいて，ユーザ入力の文字列でマッチするものを検索したい場合などには，入力された文字列を正規表現として解釈するのではなく，その文字列そのもので検索したい場合がほとんどでしょう．そのようなときに，<NOBR><CODE>$pattern</CODE></NOBR> としてパターンマッチを行なうと，先ほどの例で挙げた<NOBR>開き括弧 <CODE>(</CODE></NOBR> などが入力されたときに正規表現として正しくないとエラーになってしまいます．そこで正規表現で特別な意味として解釈される開き括弧などの<FONT COLOR="Blue">メタ文字</FONT>はエスケープしてパターンマッチさせる必要があります．<P>そのためには，ユーザ入力 <NOBR><CODE>$keyword</CODE></NOBR> に対して，これまでに書いたスクリプトの <NOBR><CODE>$pattern</CODE></NOBR> の部分を<NOBR><CODE>\Q$keyword\E</CODE></NOBR> に変更して，パターンマッチの場合は，<BLOCKQUOTE><B><PRE>if ($str =~ /^(?:$ascii|$twoBytes|$threeBytes)*?\Q$keyword\E/) {  print &quot;マッチした\n&quot;;}</PRE></B></BLOCKQUOTE>置換の場合は，<BLOCKQUOTE><B><PRE>$str =~ s/\G((?:$ascii|$twoBytes|$threeBytes)*?)\Q$keyword\E/$1$replace/g;</PRE></B></BLOCKQUOTE>というようにします．<NOBR><CODE>\Q</CODE></NOBR> から<NOBR><CODE>\E</CODE></NOBR> までメタ文字が無視されるようになります．<P>次に実行速度を上げるための方法を <NOBR>1つ</NOBR>書いておきます．これまで書いてきたように，日本語の文字列に対して正しくマッチさせたり置換するためには少々複雑な正規表現を使う必要があります．そのため，その複雑になった分だけ<FONT COLOR="Blue">実行速度が遅く</FONT>なってしまいます．これは，大量のデータの中から検索したり置換したりする場合には非常に時間がかかるようになってしまうことを意味します．<P>ここで少し考えてみてください．大量のデータの中から検索するとき，その<FONT COLOR="Blue">ほとんどの場合はマッチしない</FONT>のです．つまり，マッチしないのですから正しくマッチさせる必要はないのです．そこで <NOBR><CODE>$pattern</CODE></NOBR> を検索したいときには，次のようにすることでほとんどの場合<FONT COLOR="Red">実行速度を上げる</FONT>ことができます．<BLOCKQUOTE><B><PRE>if ($str =~ /$pattern/) {  if ($str =~ /^(?:$ascii|$twoBytes|$threeBytes)*?(?:$pattern)/) {    print &quot;マッチした\n&quot;;  }}</PRE></B></BLOCKQUOTE><P><NOBR><CODE>$keyword</CODE></NOBR> の場合は，<NOBR><CODE>/\Q$keyword\E/</CODE></NOBR> という正規表現は使わずに次のように<FONT COLOR="Red"><NOBR><CODE>index</CODE> 関数</NOBR></FONT>を使います．<BLOCKQUOTE><B><PRE>if (index($str, $keyword) &gt; -1) {  if ($str =~ /^(?:$ascii|$twoBytes|$threeBytes)*?\Q$keyword\E/) {    print &quot;マッチした\n&quot;;  }}</PRE></B></BLOCKQUOTE><P><NOBR><CODE>index</CODE> 関数</NOBR>は正規表現に比べて<FONT COLOR="Red">実行速度が圧倒的に速い</FONT>ので，なんでもかんでも正規表現ではなく，<NOBR><CODE>index</CODE> 関数</NOBR>が使えないか常に考えたいものです．<P>これまで書いてきた方法は <NOBR>EUC-JP</NOBR> だけではなく，SJIS の場合にも応用することができます．SJIS の場合にも SJIS での <NOBR>1文字</NOBR>というものを意識して正規表現を書くことになります．SJIS での <NOBR>1文字</NOBR>については，「<A HREF="#Character">文字の正規表現</A>」を参照．<P>実は，<NOBR>EUC-JP</NOBR> で <NOBR>perl5.005</NOBR> 以降という条件においては，ほとんどの場合にこれまで書いてきた方法よりも<FONT COLOR="Red">実行速度が速く</FONT>，より<FONT COLOR="Red">扱いやすい</FONT>方法があります．以下にまとめて列挙します．<BLOCKQUOTE><B><PRE># EUC-JP で perl5.005 以降限定の方法$eucpre = qr{(?&lt;!\x8F)};$eucpost = qr{    (?=                              (?:[\xA1-\xFE][\xA1-\xFE])* # JIS X 0208 が 0文字以上続いて     (?:[\x00-\x7F\x8E\x8F]|\z)  # ASCII, SS2, SS3 または終端    ) }x;if ($str =~ /$eucpre(?:$pattern)$eucpost/) {          # パターンマッチ  print &quot;マッチした\n&quot;;}if ($str =~ /$eucpre\Q$keyword\E$eucpost/) {      # キーワードマッチ  print &quot;マッチした\n&quot;;}$str =~ s/$eucpre(?:$pattern)$eucpost/$replace/g;     # パターン置換$str =~ s/$eucpre\Q$keyword\E$eucpost/$replace/g; # キーワード置換</PRE></B></BLOCKQUOTE><P>いずれの場合においても，<NOBR><CODE>$eucpre</CODE></NOBR> と<NOBR><CODE>$eucpost</CODE></NOBR> で挟むだけになります．この方法は正規表現の<FONT COLOR="Blue">後読み</FONT>(lookbehind)と<FONT COLOR="Blue">先読み</FONT>(lookahead) を使っています．後読みは<NOBR><CODE>(?&lt;regex)</CODE></NOBR>，先読みは<NOBR><CODE>(?=regex)</CODE></NOBR>という正規表現になります．このスクリプトでは後読みは否定後読みの<NOBR><CODE>(?&lt;!regex)</CODE></NOBR> の方を使っています．<P>この方法はマッチさせたい正規表現にマッチしたものがずれた位置ではないことを後読みと先読みによって保証しています．具体的には，後読みの部分で<NOBR>JIS X 0212</NOBR> の <NOBR>2バイト目</NOBR>からずれてマッチしていないかチェックしています．<NOBR>JIS X 0212</NOBR> の<NOBR>2バイト目</NOBR>からマッチしていた場合は，マッチした部分の直前に<NOBR>JIS X 0212</NOBR> の <NOBR>1バイト目</NOBR>，すなわち，<NOBR><CODE>\x8F</CODE></NOBR> があることになります．しかし，後読みによって<NOBR><CODE>\x8F</CODE></NOBR> ではないことが保証されているので，<NOBR>JIS X 0212</NOBR> の <NOBR>2バイト目</NOBR>からずれてマッチすることはなくなります．<P>また，<NOBR>JIS X 0208</NOBR> の <NOBR>2バイト目</NOBR>からずれてマッチしてしまう場合と <NOBR>JIS X 0212</NOBR> の <NOBR>3バイト目</NOBR>からずれてマッチしてしまう場合についてのチェックは先読み部分で行なっています．もし，このような位置からずれてマッチしてしまった場合，先読み部分にマッチしなくなります．先読み部分はマッチした部分の後ろに正しく <NOBR>EUC-JP</NOBR> の文字列が続いているかどうかをチェックしています．具体的には，マッチした部分の後ろから，<NOBR>JIS X 0208</NOBR>以外のものが来るまで，正しく <NOBR>JIS X0208</NOBR> 文字が続いているかどうかをチェックしています．<P>この方法では先読みと後読みだけで正しくマッチさせることができます．先読みと後読みはどちらもそれ自体にはマッチした文字列を含まない<FONT COLOR="Red"><NOBR>0文字幅</NOBR></FONT>の正規表現です．したがって，置換する場合に置換後の文字列の中に <NOBR><CODE>$eucpre</CODE></NOBR> や<NOBR><CODE>$eucpost</CODE></NOBR> にマッチした部分のことを考えての<NOBR><CODE>$1</CODE></NOBR> のようなものを必要としなくなります．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="JP_RmSpace"><HR></A><H3>前後の空白文字(全角スペース含)を削除する</H3><BLOCKQUOTE><BLOCKQUOTE><B><PRE># $str の先頭の空白文字(全角スペース含)を削除する$str =~ s/^(?:\s|$Zspace)+//o; # $str が EUC-JP の場合$str =~ s/^(?:\s|$Zspace_sjis)+//o; # $str が SJIS の場合# $str の末尾の空白文字(全角スペース含)を削除する$str =~ s/^($character*?)(?:\s|$Zspace)+$/$1/o; # $str が EUC-JP の場合$str =~ s/$eucpre(?:\s|$Zspace)+$//o; # $str が EUC-JP の場合(perl5.005以降)$str =~ s/^($character_sjis*?)(?:\s|$Zspace_sjis)+$/$1/o; # $str が SJIS の場合</PRE></B></BLOCKQUOTE><P>上記スクリプトで使用している変数については「<A HREF="#Character">文字の正規表現</A>」および「<A HREF="#JP_Match">正しくパターンマッチさせる</A>」を参照してください．<P>前後の全角スペースを含む空白文字を削除するとき，次のように書くと間違って削除してしまう可能性があります．<BLOCKQUOTE><PRE># $str の末尾の空白文字(全角スペース含)を削除する(間違い)$str =~ s/(?:\s|$Zspace)+$//o; # $str が EUC-JP の場合$str =~ s/(?:\s|$Zspace_sjis)+$//o; # $str が SJIS の場合</PRE></BLOCKQUOTE><P>先頭の空白文字を削除する場合については特に問題ありませんが，末尾の空白文字を削除するときには全角スペースがマルチバイト文字の一部などに間違ってマッチしてしまう可能性があります．例えば，SJIS で<NOBR><CODE>$str = '＠＝@';</CODE></NOBR> の場合，間違って末尾を削除してしまいます．詳しくは，「<A HREF="#JP_EUC_JP">perl スクリプトは <NOBR>EUC-JP</NOBR> で書く</A>」および「<A HREF="#JP_Match">正しくパターンマッチさせる</A>」を参照してください．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="JP_Split"><HR></A><H3>文字単位に分割する</H3><BLOCKQUOTE><P><NOBR><CODE>$str</CODE></NOBR> は<FONT COLOR="Blue"><NOBR>EUC-JP</NOBR> という前提</FONT>ですので，必要ならばあらかじめ <NOBR>EUC-JP</NOBR> に変換しておいてください．漢字コードの変換に関しては「<A HREF="#JP_Trans">漢字コードを <NOBR>EUC-JP</NOBR>に変換して処理する</A>」を参照．<BLOCKQUOTE><B><PRE># $str を文字単位に分割して配列 @chars に代入する$ascii = '[\x00-\x7F]';$twoBytes = '[\x8E\xA1-\xFE][\xA1-\xFE]';$threeBytes = '\x8F[\xA1-\xFE][\xA1-\xFE]';@chars = $str =~ /$ascii|$twoBytes|$threeBytes/og;</PRE></B></BLOCKQUOTE><P>最後の代入文をわかりやすく，<NOBR><CODE>@chars = ($str =~ /($ascii|$twoBytes|$threeBytes)/og;</CODE></NOBR>と書いてもほぼ同等の動作をします．先にそのように書いた場合の説明をします．<NOBR>EUC-JP</NOBR> での<NOBR>1文字</NOBR>が <NOBR><CODE>$ascii|$twoBytes|$threeBytes</CODE></NOBR>と正規表現で表わすことができることを「<A HREF="#JP_Match">正しくパターンマッチさせる</A>」で述べました．これを括弧で囲ってグループにしています．一方，この代入文は<NOBR>配列 <CODE>@chars</CODE></NOBR> への代入なので，右辺は<FONT COLOR="Red">リストコンテキスト</FONT>で実行されます．パターンマッチをリストコンテキストで実行すると，グループにされた正規表現にマッチする文字列のリストが返されます．つまり，<NOBR><CODE>($1, $2, $3,…)</CODE></NOBR> というリストが返されます．さらに<NOBR>修飾子 <CODE>g</CODE></NOBR> がつけられていますので，<NOBR><CODE>($1, $2, $3,…, $1, $2, $3,…)</CODE></NOBR> というリストが返されることになります．この場合はグループにされている正規表現が<NOBR>1つ</NOBR>ですので，ちょうど <NOBR>EUC-JP</NOBR> での<NOBR>1文字</NOBR>に分割されたリストが返されることになります．<P>最初のスクリプトでは <NOBR><CODE>@chars</CODE></NOBR> への代入文の右辺全体を括弧で囲っていませんが，これは <CODE>=</CODE> よりも<NOBR><CODE>=~</CODE></NOBR>の方が<FONT COLOR="Red">演算子の優先順位が高い</FONT>ので，<NOBR><CODE>@char = $str</CODE></NOBR>を先に実行してしまうということはありません．<P>また，正規表現の全体を括弧で囲っていませんが，<NOBR>修飾子<CODE>g</CODE></NOBR>がつけられているパターンマッチをリストコンテキストで実行したとき，正規表現の中に括弧が <NOBR>1つ</NOBR>もなかった場合は自動的に<FONT COLOR="Red">正規表現全体を括弧で囲ってある</FONT>ものとして動作します．このとき，正規表現全体を括弧で囲った場合よりも<FONT COLOR="Red">実行速度が速い</FONT>です．後から<NOBR><CODE>$1</CODE></NOBR> として使用するわけでもなく正規表現全体を括弧で囲うような場合には括弧をつけない方がよいでしょう．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="JP_Fold"><HR></A><H3>特定の長さで折り返す</H3><BLOCKQUOTE><BLOCKQUOTE><B><PRE># $str を $bytesバイトで折り返すrequire 'fold.pl';while (length($str)) {  (my $folded, $str) = fold($str, $bytes);  print $folded, &quot;\n&quot;;}</PRE></B></BLOCKQUOTE><P><A HREF="http://www.srekcah.org/~utashiro/perl/scripts/fold_pl/"><NOBR><TT>fold.pl</TT></NOBR></A>(歌代 和正さん作)を使うのが簡単です．<NOBR><TT>fold.pl</TT></NOBR> を使わず，「<A HREF="#JP_Cut">文字が途切れているか判定する</A>」で書いたように文字が途切れていないか判定しながら <NOBR><CODE>substr</CODE>関数</NOBR>を使って折り返すという方法もありますが，わざわざ書く必要はないでしょう．<NOBR><CODE>fold</CODE> 関数</NOBR> の<NOBR>第 3引数</NOBR>に 1 を指定すれば，折り返した結果 <NOBR><CODE>$bytes</CODE>バイト</NOBR>に満たない場合にはスペースを補って <NOBR><CODE>$bytes</CODE>バイト</NOBR>になるようにすることができます．また，<NOBR>第 4引数</NOBR>に 1 を指定すれば単語境界で折り返すようになります．詳しくは <NOBR><TT>fold.pl</TT></NOBR> の中の説明を読んでください．なお，<NOBR><TT>fold.pl</TT></NOBR> は補助漢字と SJIS の半角カタカナには対応していません．また，<NOBR>EUC-JP</NOBR> の半角カタカナは<NOBR>2バイト文字</NOBR>として扱いますので，半角カタカナが混じっていると表示幅にずれが発生します．表示幅をそろえたい場合には，半角カタカナをあらかじめ全角カタカナに変換しておくか，折り返すバイト数を適当に処理してあげる必要があります．<P>おまけとして，半角カタカナに対応した禁則処理しつつ折り返すスクリプトを載せておきます．このスクリプトは <NOBR>EUC-JP</NOBR> で書かれ，<NOBR><CODE>$str</CODE></NOBR> も <FONT COLOR="Blue"><NOBR>EUC-JP</NOBR>という前提</FONT>ですので，必要ならばあらかじめ <NOBR>EUC-JP</NOBR>に変換しておいてください．漢字コードの変換に関しては「<A HREF="#JP_Trans">漢字コードを <NOBR>EUC-JP</NOBR>に変換して処理する</A>」を参照．<BLOCKQUOTE><B><PRE># $str を禁則処理しつつ折り返すrequire 'fold.pl';require 'jcode.pl';$no_begin = &quot;!%),.:;?]}¢°’”‰′″℃、。々〉》」』】〕&quot; .    &quot;ぁぃぅぇぉっゃゅょゎ゛゜ゝゞァィゥェォッャュョヮヵヶ&quot; .    &quot;・ーヽヾ！％），．：；？］｝&quot;;              # 行頭禁則文字$no_begin_jisx0201 = &quot;。」、・ァィゥェォャュョッー゛゜&quot;;jcode::z2h_euc(\$no_begin_jisx0201);$no_begin .= $no_begin_jisx0201;                 # 行頭禁則文字(半角カタカナ)$no_end = &quot;\$([{£\‘“〈《「『【〔＄（［｛￥&quot;;  # 行末禁則文字$no_end_jisx0201 = &quot;「&quot;;jcode::z2h_euc(\$no_end_jisx0201);$no_end .= $no_end_jisx0201;                     # 行末禁則文字(半角カタカナ)$allow_end = $no_begin;                          # ぶら下げ行頭禁則文字$del_space = '(?:\s|\xA1\xA1)';                  # 削除する行頭行末空白$basebytes = 74;                                 # 基本長$maxbytes = 76;                                  # 最大長$ascii = '[\x00-\x7F]';$twoBytes = '[\x8E\xA1-\xFE][\xA1-\xFE]';$threeBytes = '\x8F[\xA1-\xFE][\xA1-\xFE]';map {$no_begin{$_} = 1;} ($no_begin =~ /$ascii|$twoBytes|$threeBytes/og);map {$no_end{$_} = 1;} ($no_end =~ /$ascii|$twoBytes|$threeBytes/og);map {$allow_end{$_} = 1 + /[\xA1-\xFE]/ - /\x8E/;}    ($allow_end =~ /$ascii|$twoBytes|$threeBytes/og);sub fold_properly {  my $str = shift;  my($folded, $strtmp, $bytestmp, $begin_char, $end_char, $flag);  $flag = 1; # 行頭禁則処理状態(1:ぶら下げ, 0:追い出し)  $bytestmp = $basebytes;  $str =~ tr/\t\n\r\f/ /; # 空白文字をスペースに変換  $str =~ s/^$del_space+//o; # 行頭空白削除  ($begin_char) = %no_begin; # 行頭禁則文字を 1文字代入  while ($no_begin{$begin_char} or $no_end{$end_char}) {    ($folded, $strtmp) = fold($str, $bytestmp, 0, 1);    while (length($folded) - ($folded =~ tr/\x8E//) &lt;= $basebytes and   $strtmp ne '' and $flag) { # 半角カタカナのための表示幅処理      ($folded, $strtmp) = fold($str, $bytestmp, 0, 1);      my ($folded_tmp, $strtmp_tmp) = fold($str, $bytestmp + 1, 0, 1);      if (length($folded_tmp) - ($folded_tmp =~ tr/\x8E//) &lt;= $basebytes) {        ($folded, $strtmp) = ($folded_tmp, $strtmp_tmp);        $bytestmp++;      } else {        last;      }    }    ($begin_char) = $strtmp =~ /^$del_space*($ascii|$twoBytes|$threeBytes)/o;    ($end_char) = $folded =~ /($threeBytes|$twoBytes|$ascii)$/o;    if ($flag) { # ぶら下げ禁則処理      if ($no_begin{$begin_char} and $allow_end{$begin_char}) { # ぶら下げ可能        if (length($folded) - ($folded =~ tr/\x8E//)            + $allow_end{$begin_char} &lt;= $maxbytes) {          $bytestmp++;        } else {          $flag = 0;          $bytestmp = $basebytes - 1 + ($folded =~ tr/\x8E//);        }      } else {        $flag = 0;        $bytestmp--;      }    } else {      $bytestmp--;    }    if ($bytestmp == 0) { # 禁則処理不可能      ($folded, $strtmp) = fold($str, $basebytes, 0, 1);      last;    }  }  $folded =~ s/^((?:$ascii|$twoBytes|$threeBytes)*?(?=$del_space))      $del_space+$/$1/ox; # 行末空白削除  ($folded, $strtmp);}while (length($str)) {  (my $folded, $str) = fold_properly($str);  print $folded, &quot;\n&quot;;}</PRE></B></BLOCKQUOTE></BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="JP_Base64"><HR></A><H3><NOBR>Base64</NOBR>エンコード・デコードする</H3><BLOCKQUOTE><P><NOBR><CODE>$str</CODE></NOBR> は<FONT COLOR="Blue"><NOBR>EUC-JP</NOBR> という前提</FONT>ですので，必要ならばあらかじめ <NOBR>EUC-JP</NOBR> に変換しておいてください．漢字コードの変換に関しては「<A HREF="#JP_Trans">漢字コードを <NOBR>EUC-JP</NOBR>に変換して処理する</A>」を参照．<BLOCKQUOTE><B><PRE># $data を Base64エンコードして $encoded_data を求めるuse MIME::Base64;$encoded_data = encode_base64($data);</PRE></B></BLOCKQUOTE><P><NOBR>Base64</NOBR>エンコードするには，<A HREF="http://search.cpan.org/search?dist=MIME-Base64"><NOBR>モジュール <CODE>MIME::Base64</CODE></NOBR></A> の<NOBR><CODE>encode_base64</CODE> 関数</NOBR>を使います．<NOBR>Base64</NOBR>エンコード・デコードについては<A HREF="http://www.csl.sony.co.jp/cgi-bin/hyperrfc?2045"><NOBR>RFC 2045</NOBR></A>(<A HREF="http://www3.cds.ne.jp/~marimo/data/rfc/rfc2045-jp.txt">日本語訳</A> )に書かれています．これによると <NOBR>Base64</NOBR>エンコードした出力ストリームの各行は<FONT COLOR="Red"><NOBR>76文字</NOBR>以内</FONT>でなければならないと書かれています．<NOBR><CODE>encode_base64</CODE> 関数</NOBR>は<NOBR>第 2引数</NOBR>を指定しないで呼んだ場合には自動的に <NOBR>76文字</NOBR>ごとに改行コードを入れて折り返してくれます．<BLOCKQUOTE><B><PRE># $encoded_data を Base64デコードして元のデータ $data に戻すuse MIME::Base64;$data = decode_base64($encoded_data);</PRE></B></BLOCKQUOTE><P><NOBR>Base64</NOBR>デコードするには，<NOBR>モジュール <CODE>MIME::Base64</CODE></NOBR> の<NOBR><CODE>decode_base64</CODE> 関数</NOBR>を使います．<NOBR><CODE>$encoded_data</CODE></NOBR> には <NOBR>76文字</NOBR>ごとに折り返すために挿入されている改行コードが入ったままでもかまいません．<P>次に <FONT COLOR="Blue"><NOBR>encoded-word</NOBR></FONT>について説明します．<NOBR>encoded-word</NOBR> については<A HREF="http://www.csl.sony.co.jp/cgi-bin/hyperrfc?2047"><NOBR>RFC 2047</NOBR></A>(<A HREF="http://www3.cds.ne.jp/~marimo/data/rfc/rfc2047-jp.txt">日本語訳</A> )に書かれています．<NOBR>encoded-word</NOBR> というのは<FONT COLOR="Blue"><NOBR><TT>=?charset?encoding?encoded-text?=</TT></NOBR></FONT>という形をしたものです．たとえば<NOBR><TT>=?ISO-2022-JP?B?GyRCTmMbKEI=?=</TT></NOBR> は<NOBR><CODE>&quot;例&quot;</CODE></NOBR> という文字列を<NOBR>encoded-word</NOBR>にしたものです．ここでは <TT>encoding</TT> に <TT>B</TT> を指定した<NOBR>encoded-word</NOBR> について説明します．<P><TT>encoding</TT> が <TT>B</TT> というのは<NOBR><TT>encoded-text</TT></NOBR> の部分が<FONT COLOR="Red"><NOBR>Bエンコード</NOBR></FONT>されたものであることを表わしています．<NOBR>Bエンコード</NOBR>というのは<NOBR>Base64</NOBR>エンコードと同じエンコード方法ですが，<NOBR>encoded-word</NOBR> の場合は <NOBR>Base64</NOBR>エンコードとは呼ばずに<NOBR>Bエンコード</NOBR>と呼びます．<BLOCKQUOTE><B><PRE># $str を Bエンコードして encoded-word に変換する(不完全)require 'jcode.pl';use MIME::Base64;jcode::convert(\$str, 'jis', 'euc', 'z');$str = '=?ISO-2022-JP?B?' . encode_base64($str, '') . '?=';</PRE></B></BLOCKQUOTE><P><NOBR>Bエンコード</NOBR>するには <NOBR><CODE>encode_base64</CODE>関数</NOBR>を使えばいいのですが，<NOBR>第 2引数</NOBR>を指定しない場合はエンコードした結果に改行コードがついてしまうので，空文字列を指定して改行コードがつかないようにしています．また，<TT>charset</TT> に<FONT COLOR="Red"><NOBR>ISO-2022-JP</NOBR></FONT> を指定する都合上，あらかじめ <NOBR><CODE>$str</CODE></NOBR> を<FONT COLOR="Red">JIS に変換</FONT>する必要があります．正確には<NOBR>ISO-2022-JP</NOBR> に変換する必要があります．<NOBR>ISO-2022-JP</NOBR>に変換するには基本的に JIS に変換してあげればいいのですが，<NOBR>ISO-2022-JP</NOBR> では半角カタカナを使うことができません．そこで半角カタカナが含まれていた場合には全角カタカナに変換する必要があります．これをやるには<NOBR><CODE>jcode::convert</CODE> 関数</NOBR>の<NOBR>第 4引数</NOBR>に<NOBR><CODE>'z'</CODE></NOBR> を指定してあげます．<P><NOBR>encoded-word</NOBR> に変換する基礎はこれだけなのですが，これはあくまでも基礎であって <NOBR>RFC 2047</NOBR> を満たすことができない不完全なものです．<NOBR>RFC 2047</NOBR> には <NOBR>encoded-word</NOBR> に変換する上で守らなければならない決まりについて．だいたい次のようなことが書かれています．<OL>  <LI><NOBR>encoded-word</NOBR> は    <FONT COLOR="Red"><NOBR>75バイト</NOBR>以内</FONT>でなければならない．  <LI><NOBR>encoded-word</NOBR> を含む行は    <FONT COLOR="Red"><NOBR>76バイト</NOBR>以内</FONT>でなければならない．  <LI><NOBR>encoded-word</NOBR>    はそれぞれ独立してデコード可能でなければならない．  <LI><NOBR>encoded-text</NOBR> をデコードした文字列の文字コードは，最後に    ASCII が指定された状態でなければならない．  <LI><NOBR>encoded-word</NOBR> が現れる出現位置に関する決まり．    <UL>      <LI>Subject や Comment のヘッダフィールドなどの，        <NOBR>'text'</NOBR> 内に出現．      <LI><NOBR><TT>&quot;(&quot;</TT></NOBR> と        <NOBR><TT>&quot;)&quot;</TT></NOBR> で区切られた        <NOBR>'comment'</NOBR> 内に出現．      <LI>From や To，CC ヘッダなどで，<NOBR>'phrase'</NOBR> 内に出現．      <LI><NOBR>'addr-spec'</NOBR> 内で出現してはならない．      <LI><FONT COLOR="Red"><NOBR>'quoted-string'</NOBR>        内で出現してはならない</FONT>．などなど．    </UL>  <LI><FONT COLOR="Blue">隣り合う <NOBR>encoded-word</NOBR> の間の    <NOBR>'linear-white-space'</NOBR> は無視する</FONT>．</OL><P>1 から 4 までが <NOBR>encoded-word</NOBR> に変換するときに関係してきます．さきほどのスクリプトでは 3 と 4 についてはクリアしていますが，1 と 2については全然気にしていません．1 と 2 についても対応するためには少々困った問題が起きます．<P>まず，1 についてですが，<NOBR>encoded-word</NOBR> の長さが<NOBR>75バイト</NOBR>を超えるような場合には，<NOBR>Bエンコード</NOBR>する対象を短くして，<NOBR>2つ</NOBR>以上の <NOBR>encoded-word</NOBR> に分けて変換しなければなりません．<NOBR>2つ</NOBR>以上の <NOBR>encoded-word</NOBR>に分けるために，<NOBR>Bエンコード</NOBR>した後の <NOBR>encoded-text</NOBR>を 3 が満たされるようにうまく分割することもできますが，それでは 4を満たすことができなくなってしまいます．4 を満たしつつ対象を短くするには，適当なところで対象の文字列を分割しては駄目で，ちゃんと<FONT COLOR="Blue">日本語の文字単位で短く</FONT>しなければなりません．つまり，漢字などの <NOBR>2バイト文字</NOBR>や<NOBR>3バイト文字</NOBR>の途中で分割しては駄目だということです．日本語の文字単位で短くすることができたら，後は<A HREF="#jcode.pl"><NOBR><TT>jcode.pl</TT></NOBR></A> を使って JIS に変換すれば，自動的に最後の文字コードが ASCII の状態になるようにしてくれます．<P>次に，2 についての困った問題というのを説明します．<NOBR>encoded-word</NOBR>を含む行が <NOBR>76バイト</NOBR>以内でなければならないということは，<NOBR>encoded-word</NOBR> に変換するときに，変換した後の行が<NOBR>76バイト</NOBR>以内になっているように <NOBR>encoded-word</NOBR>の長さを調整しなければならないということになります．もし，<NOBR>encoded-word</NOBR> に変換するとその行が <NOBR>76バイト</NOBR>を超えてしまう場合には，<FONT COLOR="Blue">改行して折り返す</FONT>必要があります．<P>以上が <NOBR>encoded-word</NOBR> への変換そのものについての少々困った問題ということになるのですが，実はそれ以前に一番困った問題というのがありまして，それが 5 です．つまり，どの部分を <NOBR>encoded-word</NOBR> に変換すればいいのか，ということが一番問題なのです．同様に，どの部分をデコードしたらいいのかというのも問題になります．文字列を与えられてうまく処理しろと言われたら字句解析や構文解析が必要になってしまいます．ここではとてもそこまではできませんので，<NOBR>encoded-word</NOBR> に変換したい部分，逆変換したい部分を与えられた場合のスクリプトを書きます．<BLOCKQUOTE><B><PRE># $str を encoded-word に変換し $line に追加するrequire 'jcode.pl';use MIME::Base64;$ascii = '[\x00-\x7F]';$twoBytes = '[\x8E\xA1-\xFE][\xA1-\xFE]';$threeBytes = '\x8F[\xA1-\xFE][\xA1-\xFE]';sub add_encoded_word {  my($str, $line) = @_;  my $result;  while (length($str)) {    my $target = $str;    $str = '';    if (length($line) + 22 +	($target =~ /^(?:$twoBytes|$threeBytes)/o) * 8 &gt; 76) {      $line =~ s/[ \t\n\r]*$/\n/;      $result .= $line;      $line = ' ';    }    while (1) {      my $encoded = '=?ISO-2022-JP?B?' .      encode_base64(jcode::jis($target, 'euc', 'z'), '') . '?=';      if (length($encoded) + length($line) &gt; 76) {	$target =~ s/($threeBytes|$twoBytes|$ascii)$//o;	$str = $1 . $str;      } else {	$line .= $encoded;	last;      }    }  }  $result . $line;}$line = add_encoded_word($str, $line);</PRE></B></BLOCKQUOTE><BLOCKQUOTE><PRE>実行例$line = 'Subject: ';$str = 'これはテストです．This is test.';$line = add_encoded_word($str, $line);print $line, &quot;\n&quot;;実行結果Subject: =?ISO-2022-JP?B?GyRCJDMkbCRPJUYlOSVIJEckOSElGyhCVGhpcyBpcyB0ZXN0?= =?ISO-2022-JP?B?Lg==?=</PRE></BLOCKQUOTE><P>このスクリプトは <NOBR><CODE>$line</CODE></NOBR> に<NOBR><CODE>$str</CODE></NOBR> を <NOBR>encoded-word</NOBR>に変換してから追加します．<NOBR><CODE>$str</CODE></NOBR> がかなり長い場合は，<NOBR>encoded-word</NOBR>が速く <NOBR>75バイト</NOBR>以内になるように当たりをつけてからやった方がいいのですがこのスクリプトでは行なっていません．また，どの部分を<NOBR>encoded-word</NOBR> にするかですが，<NOBR>RFC 2047</NOBR> には本来<NOBR>encoded-word</NOBR> に変換する必要のないもの，つまり，ASCII だけから成る単語まで変換するのは<FONT COLOR="Blue">推奨できない</FONT>と書かれています．ですから，実行例のように<TT>is</TT> や <TT>test.</TT> までいっしょに <NOBR>encoded-word</NOBR> に変換するのはあまりいい例とは言えません．これについては，Subject などのunstructured header の場合に対応したスクリプトを次に書きます．<BLOCKQUOTE><B><PRE># unstructured header $header を MIMEエンコードする# add_encoded_word() については上のスクリプトを参照sub mime_unstructured_header {  my $oldheader = shift;  my($header, @words, @wordstmp, $i) = ('');  my $crlf = $oldheader =~ /\n$/;  $oldheader =~ s/\s+$//;  @wordstmp = split /\s+/, $oldheader;  for ($i = 0; $i &lt; $#wordstmp; $i++) {    if ($wordstmp[$i] !~ /^[\x21-\x7E]+$/ and	$wordstmp[$i + 1] !~ /^[\x21-\x7E]+$/) {      $wordstmp[$i + 1] = &quot;$wordstmp[$i] $wordstmp[$i + 1]&quot;;    } else {      push(@words, $wordstmp[$i]);    }  }  push(@words, $wordstmp[-1]);  foreach $word (@words) {    if ($word =~ /^[\x21-\x7E]+$/) {      $header =~ /(?:.*\n)*(.*)/;      if (length($1) + length($word) &gt; 76) {	$header .= &quot;\n $word&quot;;      } else {	$header .= $word;      }    } else {      $header = add_encoded_word($word, $header);    }    $header =~ /(?:.*\n)*(.*)/;    if (length($1) == 76) {      $header .= &quot;\n &quot;;    } else {      $header .= ' ';    }  }  $header =~ s/\n? $//;  $crlf ? &quot;$header\n&quot; : $header;}$header = mime_unstructured_header($header);</PRE></B></BLOCKQUOTE><BLOCKQUOTE><PRE>実行例$header = &quot;Subject: ASCII 日本語 ASCIIと日本語 ASCII ASCII\n&quot;;$header = mime_unstructured_header($header);print $header;実行結果Subject: ASCII =?ISO-2022-JP?B?GyRCRnxLXDhsGyhCIEFTQ0lJGyRCJEhGfEtcGyhC?= =?ISO-2022-JP?B?GyRCOGwbKEI=?= ASCII ASCII</PRE></BLOCKQUOTE><P>このスクリプトは前述のスクリプトの関数<NOBR><CODE>add_encoded_word()</CODE></NOBR> を利用しています．前述のスクリプトの最後の<NOBR><CODE>$line = add_encoded_word($str, $line);</CODE></NOBR>を削除し，このスクリプトに変更して使います．<P>このスクリプトの前半部分で単語ごとに分割しています．ここで分割された単語ごとに，ASCII だけから成る単語かどうかを判定して<NOBR>encoded-word</NOBR> に変換するかどうかを決定していきます．このとき6 に注意する必要があります．デコードのときに <NOBR>encoded-word</NOBR> の間の<NOBR>'linear-white-space'</NOBR> は無視されるのですが，これは<NOBR>1行</NOBR>の長さが長くなってしまう場合に，<NOBR>encoded-word</NOBR>を分割するために挿入された本来不必要な <NOBR>'linear-white-space'</NOBR>を削除するためのものです．しかし，<FONT COLOR="Red">元から存在する<NOBR>'linear-white-space'</NOBR> の両側を <NOBR>encoded-word</NOBR>に変換してしまうと，デコードのときに間違って削除されてしまう</FONT>ことになります．そこで，<NOBR>'linear-white-space'</NOBR> の両側を <NOBR>encoded-word</NOBR>に変換する必要がある場合には，<NOBR>'linear-white-space'</NOBR> を含めた両側の単語を <NOBR>1つ</NOBR>の <NOBR>encoded-word</NOBR> として変換します．<BLOCKQUOTE><B><PRE># $str を Bデコードして encoded-word を元に戻すrequire 'jcode.pl';use MIME::Base64;$lws = '(?:(?:\x0D\x0A|\x0D|\x0A)?[ \t])+';$ew_regex = '=\?ISO-2022-JP\?B\?([A-Za-z0-9+/]+=*)\?=';$str =~ s/($ew_regex)$lws(?=$ew_regex)/$1/gio;$str =~ s/$lws/ /go;$str =~ s/$ew_regex/decode_base64($1)/egio;jcode::convert(\$str, 'euc', 'jis');</PRE></B></BLOCKQUOTE><P>このスクリプトは与えられた文字列 <NOBR><CODE>$str</CODE></NOBR> の中の<NOBR>encoded-word</NOBR> を元に戻します．隣り合う<NOBR>encoded-word</NOBR> の間の <NOBR>'linear-white-space'</NOBR>は無視します．<NOBR>encoded-word</NOBR> は <NOBR><TT>&quot;(&quot;</TT></NOBR>の直後であるとか，<NOBR>'linear-white-space'</NOBR> の直後であるような場合に<NOBR>encoded-word</NOBR> であって，そうでない場合は一見<NOBR>encoded-word</NOBR> に見えても，<FONT COLOR="Blue">偶然そういう文字列である</FONT>と解釈し，勝手に元に戻そうとすべきではありません．しかし，このスクリプトでは<NOBR>encoded-word</NOBR> に見えたものはすべて元に戻してしまいますので，文字列 <NOBR><CODE>$str</CODE></NOBR>を与える方でその判定を行ない，元に戻しても問題ないものだけを与える必要があります．たとえば，<NOBR><CODE>$str = q{&quot;=?ISO-2022-JP?B?GyRCTmMbKEI=?=&quot;};</CODE></NOBR> のときは<NOBR>quoted-string</NOBR> であるので，この中に <NOBR>encoded-word</NOBR>が現れるはずがありません．これを勝手に元に戻そうとしてはいけません．<P><FONT COLOR="Red"><NOBR>古い Outlook Express</NOBR> などは<NOBR>encoded-word</NOBR> に変換したものをダブルクォートで囲んで<NOBR>quoted-string</NOBR> にするので，<NOBR>RFC 2047</NOBR>を満たすことができません</FONT>．Outlook Express 5 ではこの点は修正されたようです．しかし，<FONT COLOR="Red">Outlook Express 5 を含むほとんどのメーラーは <NOBR>encoded-word</NOBR>を含む行が <NOBR>76バイト</NOBR>以内でなければならないという制約を満たしていません．</FONT><P><NOBR>encoded-word</NOBR> への変換を行なうスクリプトとして，<A HREF="http://www.cc.rim.or.jp/~ikuta/mime_pls/index.html"><NOBR>mime_pls</NOBR></A>(生田 昇さん作)というものも公開されています．しかし，これも<NOBR>RFC 2047</NOBR> を完全に満たしているわけではありません．<NOBR>encoded-word</NOBR> への変換に関しては，<NOBR><TT>Subject</TT> 行</NOBR>や <NOBR><TT>From</TT> 行</NOBR>の違いを考慮せずに同じコメント処理をしてしまいます．また，word単位で行なっていないので，たとえば <NOBR><CODE>$str = &quot;testテスト&quot;;</CODE></NOBR>のような文字列を変換，逆変換を行なうと<NOBR><CODE>&quot;test テスト&quot;</CODE></NOBR>のように余分なスペースが入ってしまいます．特殊変数 <NOBR><CODE>$`</CODE></NOBR>， <NOBR><CODE>$&amp;</CODE></NOBR>，<NOBR><CODE>$'</CODE></NOBR> を使用しているので，すべてのパターンマッチの速度が少し遅くなってしまう点は改良の余地があります．<NOBR>encoded-word</NOBR> からの逆変換に関しては，さきほど述べたように一見<NOBR>encoded-word</NOBR> に見えるものまで元に戻してしまいます．これを正しく行なうためにはどうしても構文解析が必要になります．<P><A HREF="#jcode.pl"><NOBR><TT>Jcode.pm</TT></NOBR></A> の MIMEエンコード関数 <NOBR><CODE>mime_encode</CODE></NOBR> と MIMEデコード関数<NOBR><CODE>mime_decode</CODE></NOBR> はバージョン 0.63以降で上記のスクリプトが採用されています．<P><NOBR>RFC 2047</NOBR> を完全に満たしている <NOBR>encoded-word</NOBR>への変換を行なうスクリプトとしては<A HREF="http://www.Mew.org/">IM(Internet Message)</A> の<NOBR><CODE>IM::Iso2022jp</CODE> モジュール</NOBR>があります．標準モジュールではないので，使うためには IM をインストールする必要があります．使い方は <NOBR><TT>Iso2022jp.pm</TT></NOBR> の中身を見てください．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="JP_Escape"><HR></A><H3>URIエスケープ・アンエスケープする</H3></A><BLOCKQUOTE><P><NOBR><TT>'エスケープ'</TT></NOBR> という文字列を<NOBR><TT>'%a5%a8%a5%b9%a5%b1%a1%bc%a5%d7'</TT></NOBR> のように<NOBR>URIエスケープ</NOBR>するには次のように書きます．<BLOCKQUOTE><B><PRE># $str を URIエスケープする$str =~ s/(\W)/'%' . unpack('H2', $1)/eg;</PRE></B></BLOCKQUOTE><P>逆に <NOBR><TT>'%a5%a8%a5%b9%a5%b1%a1%bc%a5%d7'</TT></NOBR>という文字列を <NOBR>URIアンエスケープ</NOBR>して<NOBR><TT>'エスケープ'</TT></NOBR>という文字列に戻すには次のように書きます．<BLOCKQUOTE><B><PRE># $str を URIアンエスケープする$str =~ s/%([0-9A-Fa-f][0-9A-Fa-f])/pack('H2', $1)/eg;</PRE></B></BLOCKQUOTE><P>私がベンチマークをとって調べた限りでは，上記のようにURIエスケープ・アンエスケープする方法が<FONT COLOR="Red">一番実行速度が速い</FONT>でしょう．これ以外の方法としては <NOBR><CODE>unpack</CODE> 関数</NOBR>を使わずに<NOBR><CODE>sprintf</CODE> 関数</NOBR>と <NOBR><CODE>ord</CODE>関数</NOBR>を使うとか，<NOBR><CODE>pack</CODE> 関数</NOBR>をフォーマット<CODE>'H2'</CODE> で使わずに<NOBR><CODE>hex</CODE> 関数</NOBR>と <NOBR><CODE>chr</CODE> 関数</NOBR>，あるいは，<NOBR><CODE>hex</CODE> 関数</NOBR>と <NOBR><CODE>pack</CODE>関数</NOBR>をフォーマット <CODE>'C'</CODE> で使うとか，<NOBR>修飾子 <CODE>i</CODE></NOBR> を使うとか，<NOBR><CODE>{2}</CODE></NOBR> を使うとかいろいろありますが，特に書く必要はないでしょう．また，<NOBR><CODE>'%A5%A8%A5%B9%A5%B1%A1%BC%A5%D7'</CODE></NOBR>のようにアルファベットを大文字に変換してもいいのですが，その場合は<NOBR><CODE>sprintf</CODE> 関数</NOBR>と <NOBR><CODE>ord</CODE>関数</NOBR>を使った方法となり，処理が遅くなります．<P>また，ハッシュと<FONT COLOR="Blue"><NOBR>演算子<CODE>||=</CODE></NOBR></FONT>を使って，次のように計算結果を再利用する方法がありますが，CGI などで使う程度ではほとんどの場合上記のスクリプトより<FONT COLOR="Red">遅い</FONT>でしょう．<BLOCKQUOTE><PRE># $str を URIエスケープする(再利用版)$str =~ s/(\W)/$escape{$1} ||= '%' . unpack('H2', $1)/eg;</PRE></BLOCKQUOTE><BLOCKQUOTE><PRE># $str を URIアンエスケープする(再利用版)$str =~ s/%([0-9A-Fa-f][0-9A-Fa-f])/$unescape{$1} ||= pack('H2', $1)/eg;</PRE></BLOCKQUOTE><P>再利用版が遅い理由は，再利用しようとする計算部分，つまり，<NOBR><CODE>'%' . unpack('H2', $1)</CODE></NOBR> や<NOBR><CODE>pack('H2', $1)</CODE></NOBR>がそれほど遅い処理ではないからです．この部分が遅い処理である場合には，一度計算した結果を数回再利用することで十分に効果が出ますが，今回の場合のようにそれほど遅い処理ではない場合には，ハッシュを使用したり <NOBR><CODE>||=</CODE></NOBR> による演算のオーバーヘッドのために逆に遅くなってしまいます．私がベンチマークをとって調べたところ，<NOBR>URIアンエスケープ</NOBR>の再利用版では<NOBR>再利用率700%</NOBR>ぐらい，つまり，一度計算したすべての結果を <NOBR>7回</NOBR>再利用したころからようやく効果が出始めるという程度でした．<P>逆に言えば，大量の文章を処理しようとした場合には効果があるということなのですが，そのような場合は次のようにあらかじめ変換テーブルを用意しておく方が<FONT COLOR="Red">実行速度が速い</FONT>です．<BLOCKQUOTE><B><PRE># $str を URIエスケープする(変換テーブル版)foreach $i (0x00 .. 0xFF) {  $escape{chr($i)} = sprintf('%%%02x', $i);}$str =~ s/(\W)/$escape{$1}/g;</PRE></B></BLOCKQUOTE><BLOCKQUOTE><B><PRE># $str を URIアンエスケープする(変換テーブル版)foreach $i (0x00 .. 0xFF) {  $unescape{sprintf('%02x', $i)} = chr($i);  $unescape{sprintf('%02X', $i)} = chr($i);}$str =~ s/%([0-9A-Fa-f][0-9A-Fa-f])/$unescape{$1}/g;</PRE></B></BLOCKQUOTE><P>変換テーブル版では最初に変換テーブルを用意するという前処理が必要になりますが，変換そのものは <FONT COLOR="Blue"><NOBR>修飾子<CODE>e</CODE></NOBR></FONT>がなくなり，文字列展開のみになるので最も実行速度が速いです．<P>ここから先は CGI や URI 特有の話になります．<P><NOBR>URIエスケープ</NOBR>するには，<A HREF="http://www.csl.sony.co.jp/cgi-bin/hyperrfc?2396"><NOBR>RFC 2396</NOBR></A>(<A HREF="http://member.nifty.ne.jp/moha/rfc/rfc2396j.txt">日本語訳</A> )で<NOBR>URI文字</NOBR>として使用できる文字 uric として定義されているもの以外をエスケープすればいいので，<NOBR><A HREF="http://search.cpan.org/search?dist=URI">モジュール <CODE>URI::Escape</CODE></A></NOBR> の<NOBR><CODE>uri_escape</CODE> 関数</NOBR>を使って，正規表現 <NOBR><CODE>[;\/?:@&amp;=+\$,A-Za-z0-9\-_.!~*'()]</CODE></NOBR>で表わされる文字以外をエスケープすればいいという話がありますが，これは<FONT COLOR="Red">間違い</FONT>です．正確には，ある意味ではそれでいいのですが，おそらく CGI を書く人にとってはほとんどの場合間違いでしょう．<NOBR><CODE>uri_escape</CODE>関数</NOBR>がやろうとしているのは，URI を入力としたときに <NOBR>URI文字</NOBR>以外の文字をエスケープすることであって，CGI を書く人がなんらかの値をエスケープしようとすることとは意味が違います．たとえば，<NOBR><CODE>$value = 'A&amp;B=C';</CODE></NOBR> のとき，<NOBR><CODE>print &quot;http://foo.bar/cgi-bin/hoge.cgi?value=$value&quot;;</CODE></NOBR>とすることを考えたらどうなると思いますか？<NOBR><CODE>uri_escape</CODE> 関数</NOBR>を使って<NOBR><CODE>$value</CODE></NOBR> をエスケープしても <CODE>&amp;</CODE> や<CODE>=</CODE> は <NOBR>URI文字</NOBR>なのでエスケープはされません．この結果，<NOBR><CODE>value=A</CODE></NOBR> と <NOBR><CODE>B=C</CODE></NOBR> という<NOBR>2つ</NOBR>を <CODE>&amp;</CODE> でつなげていると解釈されてしまいます．実は <NOBR><CODE>uri_escape</CODE> 関数</NOBR>は<NOBR>第 2引数</NOBR>で変換対象とする文字を与えることができます．ただ，やっている内容は上に書いたスクリプトと同じことなので，わざわざ標準ではない<NOBR>モジュール<CODE>URI::Escape</CODE></NOBR> をインストールして使うこともないでしょう．<P>次に，スペースと <TT>+</TT> の相互変換の話をします．CGI に何らかのデータを渡す方法としては，FORM の GET または POST を使う方法とコマンドライン引数として渡す方法の <NOBR>2つ</NOBR>があります．この <NOBR>2つ</NOBR>方法ではそれぞれスペースと <TT>+</TT> の相互変換の話が違っています．FORM の GET または POST を使う方法については<A HREF="http://www.w3.org/TR/REC-html40"><NOBR>HTML 4.0</NOBR></A>(<A HREF="http://www.asahi-net.or.jp/~bd9y-ktu/html4rec_f/cover.html">日本語訳</A> ) の <NOBR>17.13.4</NOBR> Form content types に content types がデフォルトの <NOBR>application/x-www-form-urlencoded</NOBR> のときのエンコード方法として書かれています．コマンドライン引数として渡す方法については<A HREF="http://web.golux.com/coar/cgi/draft-coar-cgi-v11-03-clean.html"><NOBR>CGI/1.1</NOBR></A>の 5. The CGI Script Command Line に書かれています．<P><NOBR>application/x-www-form-urlencoded</NOBR> でのエンコードではcontrol names と values のスペースは <TT>+</TT> に変換し，それ以外の予約文字を <NOBR><TT>%HH</TT></NOBR> の形式に <NOBR>URIエスケープ</NOBR>します．そして，controle names と values を <TT>=</TT> で区切った組とし，その組を <TT>&amp;</TT> で区切って並べます．つまり，スペースは <TT>+</TT>に変換し，それ以外の予約文字を <NOBR>URIエスケープ</NOBR>した上で，<NOBR><TT>name1=value1&amp;name2=value2</TT></NOBR>というような形式にすることです．control names や values に対して行なう文字処理部分は次のようになります．<BLOCKQUOTE><B><PRE># $str に対しエンコードの文字処理部分を行なう$str =~ s/([^\w ])/'%' . unpack('H2', $1)/eg;$str =~ tr/ /+/;</PRE></B></BLOCKQUOTE><P>スペースは <TT>+</TT> に変換しなければならないので，<NOBR>URIエスケープ</NOBR>した後で <NOBR><CODE>s/%20/+/g;</CODE></NOBR> と再度変換しなおす方法もありますが，このスクリプトのようにスペースに対して余計な処理を行なわないようにした方が<FONT COLOR="Red">実行速度が速い</FONT>です．<BLOCKQUOTE><B><PRE># $str に対しデコードの文字処理部分を行なう$str =~ tr/+/ /;$str =~ s/%([0-9A-Fa-f][0-9A-Fa-f])/pack('H2', $1)/eg;</PRE></B></BLOCKQUOTE><P>先に <NOBR>URIアンエスケープ</NOBR>してしまうと，<CODE>+</CODE> に変換されているスペースと区別がつかなくなるので，その前に<CODE>+</CODE> をスペースに戻しておきます．このとき <NOBR><CODE>$str =~ s/\+/ /g;</CODE></NOBR> としても可能ですが，文字単位の変換なので<FONT COLOR="Red">実行速度が速い</FONT><NOBR><CODE>tr</CODE> 関数</NOBR>を使います．<P>世間一般で使用されている <NOBR>URLエンコード</NOBR>というのが何を指しているのか私にはよくわからないのですが，<NOBR>application/x-www-form-urlencoded</NOBR> でのエンコードのことを<NOBR>URLエンコード</NOBR>と言うのであれば，予約文字を<NOBR><TT>%HH</TT></NOBR> の形式に変換する <NOBR>URIエスケープ</NOBR>の処理だけを指して<NOBR>URLエンコード</NOBR>と言うのは<FONT COLOR="Red">間違い</FONT>になります．もし，<NOBR>URIエスケープ</NOBR> のことを <NOBR>URLエンコード</NOBR>と言うのであれば，スペースを <TT>+</TT>に変換しなければならないというのは<FONT COLOR="Red">間違い</FONT>になります． <P>一方，コマンドライン引数として渡す方法ですが，この方法の書式は<NOBR><TT>search-string = search-word *( &quot;+&quot; search-word )</TT></NOBR>となっています．具体的な例で言いますと，<NOBR><TT>http://foo.bar/cgi-bin/hoge.cgi?arg1+arg2+arg3</TT></NOBR> のようになります．このとき<FONT COLOR="Red">スペースを <TT>+</TT> に変換するという話はどこにもありません</FONT>．<NOBR><TT>search-string</TT></NOBR> 同士を区切っている <TT>+</TT> は最初から <TT>+</TT> であって，スペースを変換したものではないのです．もし，<NOBR><TT>search-string</TT></NOBR> にスペースが含まれていた場合には，その他の予約文字と同様<NOBR>URIエスケープ</NOBR>されることになるので <NOBR><TT>%20</TT></NOBR> に変換されることになります．スペースを間違って <TT>+</TT> に変換してしまうと，たとえば <NOBR><CODE>$value = 'A B C';</CODE></NOBR>のとき，これを CGI の引数として渡そうと<NOBR><CODE>print &quot;http://foo.bar/cgi-bin/hoge.cgi?$value&quot;;</CODE></NOBR>とすることを考えたら，<NOBR><CODE>http://foo.bar/cgi-bin/hoge.cgi?A+B+C</CODE></NOBR>となり，このとき <NOBR><TT>hoge.cgi</TT></NOBR> は <NOBR>3つ</NOBR>の引数<NOBR><CODE>'A'</CODE></NOBR>，<NOBR><CODE>'B'</CODE></NOBR>，<NOBR><CODE>'C'</CODE></NOBR> を受け取ることになってしまいます．これは <NOBR><TT>http://foo.bar/cgi-bin/hoge.cgi?A%20B%20C</TT></NOBR>とするのが正解になります．<P>コマンドライン引数として渡す方法ではスペースが <TT>+</TT> に変換されているわけではないので，受け取った側で <TT>+</TT> をスペースに戻すようなことをしてはいけないということになります．コマンドライン引数として渡す方法でも<NOBR><TT>QUERY_STRING</TT></NOBR> から <NOBR>query 部分</NOBR>，つまり，<NOBR><TT>?</TT> 以降</NOBR>の部分を取得することができます．もし，FORM の GET または POST を使う方法とコマンドライン引数として渡す方法のどちらでデータが渡されるのかわからない場合に，<NOBR><TT>QUERY_STRING</TT></NOBR> からデータをもらって処理するためには，<TT>+</TT> をスペースに変換すべきか変換すべきではないのか判断する必要があります．判断する方法は簡単で，<NOBR><TT>QUERY_STRING</TT></NOBR> に<TT>=</TT> が含まれているかどうかを調べます．もし含まれていれば，それは<NOBR>application/x-www-form-urlencoded</NOBR> でのエンコードをされていることになります．含まれていなければ，コマンドライン引数としてデータが渡されたことになります．</BLOCKQUOTE></BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="CRLF_Unify"><HR></A><H2>改行コードを統一する</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE>s/\x0D\x0A|\x0D|\x0A/\n/g;</PRE></B></BLOCKQUOTE><P>このスクリプトは Windows(DOS)，Mac，UNIX のいずれかのプラットフォームの改行コードを自プラットフォームの改行コードに統一します．改行コードはWindows(DOS)では <FONT COLOR="Blue"><NOBR><CODE>\x0D\x0A</CODE></NOBR></FONT>，Macでは <FONT COLOR="Blue"><CODE>\x0D</CODE></FONT>，UNIX では<FONT COLOR="Blue"><CODE>\x0A</CODE></FONT> なので，これらすべての改行コードに対応するには<NOBR><CODE>\x0D\x0A|\x0D|\x0A</CODE></NOBR> とする必要があります．このとき順番は <FONT COLOR="Red"><NOBR><CODE>\x0D\x0A</CODE></NOBR>を必ず最初</FONT>にしなければなりません．<P>改行コードを統一するために <NOBR><CODE>s/\r\n|\r/\n/g;</CODE></NOBR>と書くのは<FONT COLOR="Red">間違い</FONT>です．このように書いて正常に動作するのはWindows(DOS) と UNIX の perl のみで，Mac の perl では正常に動作しません．よく「改行コードは Windows(DOS) では <NOBR><CODE>\r\n</CODE></NOBR>，Mac では<NOBR><CODE>\r</CODE></NOBR>，UNIX では <NOBR><CODE>\n</CODE></NOBR>である」という人がいますが，これはある意味正しいと言えなくもないのですが，根本的には間違っています．以降で何がどう間違っているのか説明しますが，その前に実際の値としての改行コード値と論理的な改行文字が別物であるということを頭の片隅にとどめておいてください．<P>まず，実際の値としての改行コード値が Windows(DOS)では<NOBR><CODE>\x0D\x0A</CODE></NOBR>，Macでは <NOBR><CODE>\x0D</CODE></NOBR>，UNIX では <NOBR><CODE>\x0A</CODE></NOBR>であるということは特に問題ないでしょう．それでは<NOBR><CODE>\r</CODE></NOBR> や <NOBR><CODE>\n</CODE></NOBR>というのは一体何なのでしょうか？答えはそれぞれ <FONT COLOR="Red">Perl という言語の中で論理的に定義された</FONT>復帰文字と改行文字です．プラットフォームによって改行コード値は <NOBR><CODE>\x0D\x0A</CODE></NOBR>であったり，<NOBR><CODE>\x0D</CODE></NOBR> や <NOBR><CODE>\x0A</CODE></NOBR>であったりするわけですが，改行するためにはどのプラットフォームであろうとPerl という言語では論理的な改行文字である<NOBR><CODE>\n</CODE></NOBR> を出力することになります．つまり，「改行はWindows(DOS) でも Mac でも UNIX でも <NOBR><CODE>\n</CODE></NOBR>」なのです．<P>それでは <NOBR><CODE>\r</CODE></NOBR> と <NOBR><CODE>\n</CODE></NOBR>が実際にどのようなコード値になっているのかまとめたものが以下の表になります(Macは推測．間違いはご指摘ください)．<TABLE BORDER=1><TR>  <TH>  <TH><CENTER>Windows(DOS)</CENTER>  <TH><CENTER>Mac</CENTER>  <TH><CENTER>UNIX</CENTER><TR>  <TD><CENTER>改行コード値</CENTER>  <TD><CENTER><FONT COLOR="Blue"><NOBR><CODE>\x0D\x0A</CODE></NOBR></FONT></CENTER>  <TD><CENTER><FONT COLOR="Blue"><NOBR><CODE>\x0D</CODE></NOBR></FONT></CENTER>  <TD><CENTER><FONT COLOR="Blue"><NOBR><CODE>\x0A</CODE></NOBR></FONT></CENTER><TR>  <TD><CENTER>改行文字</CENTER>  <TD><CENTER><FONT COLOR="Red"><NOBR><CODE>\n</CODE></NOBR></FONT></CENTER>  <TD><CENTER><FONT COLOR="Red"><NOBR><CODE>\n</CODE></NOBR></FONT></CENTER>  <TD><CENTER><FONT COLOR="Red"><NOBR><CODE>\n</CODE></NOBR></FONT></CENTER><TR>  <TD><CENTER>復帰文字</CENTER>  <TD><CENTER><NOBR><CODE>\r</CODE></NOBR></CENTER>  <TD><CENTER><NOBR><CODE>\r</CODE></NOBR></CENTER>  <TD><CENTER><NOBR><CODE>\r</CODE></NOBR></CENTER><TR>  <TD><CENTER><NOBR><CODE>print FH &quot;\n&quot;;</CODE></NOBR></CENTER>  <TD><CENTER><FONT COLOR="Blue"><NOBR><CODE>\x0D\x0A</CODE></NOBR></FONT>    を出力</CENTER>  <TD><CENTER><FONT COLOR="Blue"><NOBR><CODE>\x0D</CODE></NOBR></FONT>    を出力</CENTER>  <TD><CENTER><FONT COLOR="Blue"><NOBR><CODE>\x0A</CODE></NOBR></FONT>    を出力</CENTER><TR>  <TD><CENTER><NOBR><CODE>print FH &quot;\r&quot;;</CODE></NOBR></CENTER>  <TD><CENTER><NOBR><CODE>\x0D</CODE></NOBR> を出力</CENTER>  <TD><CENTER><NOBR><CODE>\x0A</CODE></NOBR> を出力</CENTER>  <TD><CENTER><NOBR><CODE>\x0D</CODE></NOBR> を出力</CENTER><TR>  <TD><CENTER><NOBR><CODE>binmode FH;<BR>print FH "\n";</CODE></NOBR></CENTER>  <TD><CENTER><NOBR><CODE>\x0A</CODE></NOBR> を出力</CENTER>  <TD><CENTER><NOBR><CODE>\x0D</CODE></NOBR> を出力</CENTER>  <TD><CENTER><NOBR><CODE>\x0A</CODE></NOBR> を出力</CENTER><TR>  <TD><CENTER><NOBR><CODE>print FH &quot;\r\n&quot;;</CODE></NOBR></CENTER>  <TD><CENTER><NOBR><CODE>\x0D\x0D\x0A</CODE></NOBR> を出力</CENTER>  <TD><CENTER><NOBR><CODE>\x0A\x0D</CODE></NOBR> を出力</CENTER>  <TD><CENTER><NOBR><CODE>\x0D\x0A</CODE></NOBR> を出力</CENTER><TR>  <TD><CENTER><NOBR><CODE>binmode FH;<BR>print FH &quot;\r\n&quot;;</CODE></NOBR></CENTER>  <TD><CENTER><NOBR><CODE>\x0D\x0A</CODE></NOBR> を出力</CENTER>  <TD><CENTER><NOBR><CODE>\x0A\x0D</CODE></NOBR> を出力</CENTER>  <TD><CENTER><NOBR><CODE>\x0D\x0A</CODE></NOBR> を出力</CENTER></TABLE><P>自プラットフォームの改行コード値だけを対象にしているのならば，たとえば，UNIX の perl ならば <NOBR><CODE>\x0D</CODE></NOBR> は<NOBR><CODE>\r</CODE></NOBR> であり， <NOBR><CODE>\x0A</CODE></NOBR> は<NOBR><CODE>\n</CODE></NOBR> であるとすることができます．ただし，その場合でもテキスト処理するときに限られます．何らかのバイナリファイル内の <NOBR><CODE>\x0A</CODE></NOBR>が改行を意味するわけではないからです．当然，改行コードを統一するスクリプトというように，自プラットフォーム以外の改行コード値のことも考えて処理する場合には勝手に<NOBR><CODE>\x0D</CODE></NOBR> は <NOBR><CODE>\r</CODE></NOBR> で，<NOBR><CODE>\x0A</CODE></NOBR> は <NOBR><CODE>\n</CODE></NOBR>だと決めつけてはいけません．<NOBR><CODE>\r</CODE></NOBR> や<NOBR><CODE>\n</CODE></NOBR> はあくまでも論理的な文字なのです．最初のスクリプトは，Windows(DOS)，Mac，UNIXでの実際の改行コード値を論理的な改行文字に置換しているという意味になります．<P>最初のスクリプトは簡潔でわかりやすく書かれてはいますが，<FONT COLOR="Blue">実行速度は遅い</FONT>です． 次のように <CODE>tr</CODE> を使って<NOBR>2文</NOBR>でやった方が<FONT COLOR="Red">圧倒的に速い</FONT>です． <BLOCKQUOTE><B><PRE>s/\x0D\x0A/\n/g;tr/\x0D\x0A/\n\n/;</PRE></B></BLOCKQUOTE><P>なお，Perl内部では Windows(DOS) でも Mac でも UNIX でも，<NOBR><CODE>\r</CODE></NOBR> は  <NOBR><CODE>\x0D</CODE></NOBR> か<NOBR><CODE>\x0A</CODE></NOBR> のどちらかであり，<NOBR><CODE>\n</CODE></NOBR> はその逆であるという特性を利用することで，次のように書くことが可能です．<BLOCKQUOTE><B><PRE>s/\x0D\x0A/\n/g;tr/\r/\n/;        # 意味的には tr/\x0D\x0A/\n\n/;</PRE></B></BLOCKQUOTE><P>このスクリプトの方が，<CODE>tr</CODE>で変換が行なわれなかった場合において，わずかに実行速度が速くなります．ただし，これまで述べてきたように意味的には間違った書き方であることを十分理解した上で使う必要があります．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="CRLF_2BR"><HR></A><H2>改行コードを <NOBR>&lt;BR&gt;</NOBR> に変換する</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE>s/\x0D\x0A|\x0D|\x0A/&lt;BR&gt;/g;</PRE></B></BLOCKQUOTE><P>改行コードは Windows(DOS)では<FONT COLOR="Blue"><NOBR><CODE>\x0D\x0A</CODE></NOBR></FONT>，Macでは <FONT COLOR="Blue"><NOBR><CODE>\x0D</CODE></NOBR></FONT>，UNIX では <FONT COLOR="Blue"><NOBR><CODE>\x0A</CODE></NOBR></FONT> なので，これらすべての改行コードに対応するには<NOBR><CODE>\x0D\x0A|\x0D|\x0A</CODE></NOBR>とする必要があります．このとき順番は<FONT COLOR="Red"><NOBR><CODE>\x0D\x0A</CODE></NOBR>を必ず最初</FONT>にしなければなりません．このスクリプトは簡潔でわかりやすく書かれてはいますが，<FONT COLOR="Blue">実行速度は遅い</FONT>です．<NOBR><CODE>s/\x0D\x0A|[\x0D\x0A]/&lt;BR&gt;/g;</CODE></NOBR>とするとほんの少し速くなりますが，ほとんどの場合次のように<NOBR>3文</NOBR>でやった方が<FONT COLOR="Red">圧倒的に速い</FONT>です．<BLOCKQUOTE><B><PRE>s/\x0D\x0A/&lt;BR&gt;/g;s/\x0D/&lt;BR&gt;/g;s/\x0A/&lt;BR&gt;/g;</PRE></B></BLOCKQUOTE><P>改行について詳しくは「<A HREF="#CRLF_Unify">改行コードを統一する</A>」を参照．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="CRLF_Remove"><HR></A><H2>改行コードを削除する</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE>tr/\x0D\x0A//d;</PRE></B></BLOCKQUOTE><P>「<A HREF="#CRLF_2BR">改行コードを <NOBR>&lt;BR&gt;</NOBR>に変換する</A>」と同じ手法で，<NOBR><CODE>s/\x0D\x0A|\x0D|\x0A//g;</CODE></NOBR>と書いても改行コードを削除することができます．また，<NOBR>&lt;BR&gt;</NOBR>に変換する場合と違って，<NOBR><CODE>\x0D</CODE></NOBR>，<NOBR><CODE>\x0A</CODE></NOBR>という <NOBR>2つ</NOBR>の文字を両方とも削除すればいいので，<NOBR><CODE>s/[\x0D\x0A]//g;</CODE></NOBR> と書いても同じことができます．しかし，このように<FONT COLOR="Blue">文字単位で変換</FONT>する場合は，<NOBR><CODE>tr/\x0D\x0A//d;</CODE></NOBR> と書いた方が<NOBR><CODE>s/\x0D\x0A|\x0D|\x0A//g;</CODE></NOBR> や<NOBR><CODE>s/[\x0D\x0A]//g;</CODE></NOBR>とするよりも<FONT COLOR="Red">実行速度が速い</FONT>ので，<CODE>tr</CODE> を使って改行コードを削除するようにするのがいいでしょう．<P>ここで注意が必要なのは，この方法で改行コードを削除すると，<FONT COLOR="Blue">文字列の中に含まれるすべて</FONT>の改行コードが削除されるということです．<NOBR>1行</NOBR>入力された場合のように，<FONT COLOR="Blue">文字列の最後</FONT>にだけ改行コードがあるとわかっているときは， <CODE>chomp</CODE> を使います．ただし， <CODE>chomp</CODE>は Windows(DOS) や Mac，UNIXといった<FONT COLOR="Red">処理系に依存</FONT>します．<NOBR><CODE>\x0D\x0A</CODE></NOBR> を UNIX の perl で <CODE>chomp</CODE>した場合は， <NOBR><CODE>\x0D</CODE></NOBR> が残ってしまいます．もし，複数の処理系の改行コードを想定しなければならない場合は，次のようにして<FONT COLOR="Blue">文字列の最後</FONT>の改行を削除します．<BLOCKQUOTE><B><PRE>s/\x0D?\x0A?$//;</PRE></B></BLOCKQUOTE><P>改行について詳しくは「<A HREF="#CRLF_Unify">改行コードを統一する</A>」を参照．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="CSV2Values"><HR></A><H2>CSV形式の行から値のリストを取り出す</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># CSV形式の $line から値を取り出して @values に入れる{  my $tmp = $line;  $tmp =~ s/(?:\x0D\x0A|[\x0D\x0A])?$/,/;  @values = map {/^&quot;(.*)&quot;$/ ? scalar($_ = $1, s/&quot;&quot;/&quot;/g, $_) : $_}                ($tmp =~ /(&quot;[^&quot;]*(?:&quot;&quot;[^&quot;]*)*&quot;|[^,]*),/g);}</PRE></B></BLOCKQUOTE><P><NOBR>CSV(Comma Separated Value)形式</NOBR>というのは，完全に<FONT COLOR="Red">アプリケーションに依存</FONT>した形式であるので，このスクリプトであらゆるアプリケーションが扱う <NOBR>CSV形式</NOBR>の行から値を取り出せるわけではありません．このスクリプトはもっとも需要があると思われ，また，比較的一般的な定義である Excel が出力する<NOBR>CSV形式</NOBR>について扱うこととしました．Excel が出力する<NOBR>CSV形式</NOBR>がどのようなものか Excel のヘルプに載っていませんでしたが，私が独自に調べた結果以下のようなものであるとしました．<OL>  <LI>基本的にコンマで区切った部分がスペースを含めて値である．  <LI>値にコンマやダブルクウォートが含まれる場合は，      値全体をダブルクウォートで囲む．  <LI>値に含まれるダブルクウォートは <NOBR>&quot;&quot;</NOBR> となる．</OL><P>このスクリプトでは，まずはじめに <NOBR><CODE>$line</CODE></NOBR> のコピーを<NOBR><CODE>$tmp</CODE></NOBR> に取ってから処理しています．コピーを取らずに処理すると，次の処理で <NOBR><CODE>$line</CODE></NOBR> を変更してしまうことになるためです．具体的には，抽出処理を簡単にするために，最後の値の後ろにコンマをつけ加えています．このとき <NOBR><CODE>$line</CODE></NOBR> の最後に改行コードがついていた場合を考え，改行コードの削除も同時に行なっています．ここまでの処理で <NOBR><CODE>$line</CODE></NOBR> の中身は<NOBR><TT>値,値,値,</TT></NOBR> というように <NOBR><TT>値,</TT></NOBR>の繰り返しになっています．<P>次に <NOBR><TT>値,値,値,</TT></NOBR> という形から個々の値を取り出すわけですが，これを行なうために<FONT COLOR="Blue"><NOBR>修飾子 <CODE>g</CODE></NOBR></FONT> をつけたパターンマッチを行ないます．<NOBR>修飾子 <CODE>g</CODE></NOBR> をつけたパターンマッチを<FONT COLOR="Red">リストコンテキスト</FONT>で実行すると，<NOBR><CODE>()</CODE></NOBR>によるグループにマッチした部分文字列のリストを返します．値の部分にマッチする正規表現をグループにしておけば，値のリストを取り出すことができるわけです．<P>ここで注意が必要なのは，<NOBR><TT>値,</TT></NOBR> となっているものと，<NOBR><TT>&quot;値&quot;,</TT></NOBR> となっているものの<NOBR>2種類</NOBR>があることです．そして，<NOBR><TT>&quot;値&quot;,</TT></NOBR>の形の方の値にはコンマが含まれている可能性があります．したがって，単純に <NOBR><CODE>split /,/, $tmp</CODE></NOBR> や<NOBR><CODE>($tmp =~ /([^,]*),/g)</CODE></NOBR> のようにしてしまうと，値の中のコンマによって値が <NOBR>2つ</NOBR>に別れてしまうことになります．そこでまずは値を区切っているコンマで <TT>値</TT> と<NOBR><TT>&quot;値&quot;</TT></NOBR> を正確に取り出すことを考えます．<P><NOBR><TT>値,</TT></NOBR> の形の値にはコンマが含まれていませんから，<TT>値</TT> の部分にマッチさせるには<NOBR><CODE>/([^,]*),/</CODE></NOBR> とすればいいことになります．一方，<NOBR><TT>&quot;値&quot;,</TT></NOBR> の形の<NOBR><TT>&quot;値&quot;</TT></NOBR>の部分にマッチさせるには，<NOBR><CODE>/(&quot;[^&quot;]*&quot;),/</CODE></NOBR>とすればいいように思うかもしれませんが，<NOBR>CSV形式</NOBR>の<NOBR>3番目</NOBR>の定義により，値には <NOBR><CODE>&quot;&quot;</CODE></NOBR>というのが含まれている可能性があります．そこで，<NOBR><CODE>[^&quot;]</CODE></NOBR> 以外に<NOBR><CODE>&quot;&quot;</CODE></NOBR> の場合も考え，<NOBR><CODE>/(&quot;(?:[^&quot;]|&quot;&quot;)*&quot;),/</CODE></NOBR>とすればいいことになります．この <NOBR>2つ</NOBR>の形を合成して，<NOBR><TT>($tmp =~ /(&quot;(?:[^&quot;]|&quot;&quot;)*&quot;|[^,]*),/g)</TT></NOBR> となります．これで <TT>値</TT> または <NOBR><TT>&quot;値&quot;</TT></NOBR> のリストとして取り出すことができます．ただ，正規表現の部分はこのままでもいいのですが，スクリプトではさらにこの正規表現を <NOBR>Jeffrey E. F. Friedl</NOBR>氏原著による「<A HREF="http://www.oreilly.co.jp/BOOK/regex.htm">詳説正規表現</A>(<A HREF="http://www.oreilly.com/catalog/regex/">Mastering Regular Expressions </A>)」で「<FONT COLOR="Blue">ループ展開</FONT>」として書かれている手法で変形し<FONT COLOR="Red">実行速度を速く</FONT>してあります．<P>最後に <NOBR><TT>&quot;値&quot;</TT></NOBR> から値を復元する必要があります．<NOBR><TT>値</TT></NOBR> の形ならそのまま，<NOBR><TT>&quot;値&quot;</TT></NOBR>の形ならば両側のダブルクウォートを取り除き，さらに<NOBR><CODE>&quot;&quot;</CODE></NOBR> は <TT>&quot;</TT> に変換します．この処理を <NOBR><CODE>map</CODE> 関数</NOBR> の中で行なっています．これで<NOBR>CSV形式</NOBR>の行から値を取り出すことができます．<P><A HREF="http://search.cpan.org/search?dist=Text-CSV"><NOBR>モジュール <CODE>Text::CSV</CODE></NOBR></A> を使えば同じようなことができますが，ASCII しか扱えないので日本語が含まれる場合には使えません．<A HREF="http://search.cpan.org/search?dist=Text-CSV_XS"><NOBR>モジュール <CODE>Text::CSV_XS</CODE></NOBR></A>をバイナリモードで使えば日本語を扱うことができます．ただし，どちらのモジュールも標準ではないためアーカイブファイルを取ってきてインストールする必要があります．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="CSVwithCRLF"><HR></A><H2>値に改行コードを含む CSV形式を扱う</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># 値に改行コードを含む CSV形式を扱うwhile (my $line = &lt;DATA&gt;) {  $line .= &lt;DATA&gt; while ($line =~ tr/&quot;// % 2 and !eof(DATA));  $line =~ s/(?:\x0D\x0A|[\x0D\x0A])?$/,/;  @values = map {/^&quot;(.*)&quot;$/s ? scalar($_ = $1, s/&quot;&quot;/&quot;/g, $_) : $_}                ($line =~ /(&quot;[^&quot;]*(?:&quot;&quot;[^&quot;]*)*&quot;|[^,]*),/g);  # @values を処理する}</PRE></B></BLOCKQUOTE><P>値に改行コードを含む <NOBR>CSV形式</NOBR>は「<A HREF="#CSV2Values"><NOBR>CSV形式</NOBR>の行から値のリストを取り出す</A>」で書いた Excel が出力する<NOBR>CSV形式</NOBR>を以下のように修正したものであるとしました．<OL>  <LI>基本的にコンマで区切った部分がスペースを含めて値である．  <LI>値にコンマやダブルクウォート，      <FONT COLOR="Blue">改行コード</FONT>が含まれる場合は，      値全体をダブルクウォートで囲む．  <LI>値に含まれるダブルクウォートは <NOBR>&qout;&quot;</NOBR> となる．</OL><P><NOBR>CSV形式</NOBR>の <NOBR>1行</NOBR>に現れるダブルクウォートは，<NOBR><TT>&quot;値&quot;</TT></NOBR> のように値を囲む場合と，値に含まれていたダブルクウォートが <NOBR>&quot;&quot;</NOBR>となっている場合です．したがって，<NOBR>CSV形式</NOBR>の <NOBR>1行</NOBR>には，ダブルクウォートが必ず<FONT COLOR="Blue">偶数個</FONT>あることになります．もし，ダブルクウォートが奇数個だった場合には，値に含まれる改行コードによって，もともと <NOBR>1行</NOBR>の <NOBR>CSV形式</NOBR>だった行が複数行に別れてしまっていることになります．<P>そこでダブルクウォートの数を数え，奇数個だった場合には次の行を追加します．これをダブルクウォートが偶数個になるまで繰り返します．<NOBR><CODE>tr/&quot;//</CODE></NOBR> でダブルクウォートの数を数えています．こうして正しく <NOBR>CSV形式</NOBR>の<NOBR>1行</NOBR>を取り出すことができたら，あとは「<A HREF="#CSV2Values"><NOBR>CSV形式</NOBR>の行から値のリストを取り出す</A>」とほとんど同じスクリプトで処理することができます．唯一の違いは<NOBR><CODE>map</CODE> 関数</NOBR>の中でのパターンマッチで，<FONT COLOR="Red"><NOBR>修飾子 <CODE>s</CODE></NOBR></FONT>をつけていることです．<NOBR>修飾子 <CODE>s</CODE></NOBR> をつけることによって，<FONT COLOR="Blue">ピリオドが改行コードにもマッチ</FONT>するようになります．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="CSVfromValues"><HR></A><H2>値のリストから CSV形式に変換する</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># 値の配列 @values から CSV形式の行 $line に変換する$line = join ',', map {(s/&quot;/&quot;&quot;/g or /[\r\n,]/) ? qq(&quot;$_&quot;) : $_} @values;</PRE></B></BLOCKQUOTE><P>このスクリプトは，値の配列から「<A HREF="#CSV2Values"><NOBR>CSV形式</NOBR>の行から値のリストを取り出す</A>」や「<A HREF="#CSVwithCRLF">値に改行コードを含む<NOBR>CSV形式</NOBR>を扱う</A>」で定義した <NOBR>CSV形式</NOBR>の行に変換するものです．<P>値をコンマで区切って結合させる前に，ダブルクウォート・改行コード・コンマのいずれかが含まれる値については，<NOBR><TT>&quot;値&quot;</TT></NOBR> の形に変換する必要があります．また，ダブルクウォートについては，<NOBR>&quot;&quot;</NOBR>に変換しておく必要があります．これを <NOBR><CODE>map</CODE> 関数</NOBR>によって一度に行なってしまっています．<P><NOBR><CODE>s///</CODE></NOBR> は置換を行ない，<FONT COLOR="Blue">その回数を返します</FONT>．したがって， <NOBR><CODE>s/&quot;/&quot;&quot;/g</CODE></NOBR> というのは，ダブルクウォートがあればそれを <NOBR><CODE>&quot;&quot;</CODE></NOBR>に置換し，置換した回数，つまりこの場合は値に含まれていたダブルクウォートの個数を返すことになります．この個数が 1以上，または改行コードかコンマが含まれていた場合に<NOBR><TT>&quot;値&quot;</TT></NOBR> の形に変換しています．<P>このスクリプトによって得られる <NOBR><CODE>$line</CODE></NOBR>には最後に改行コードが含まれていませんので，ファイルなどに書き出すときには次のように改行コードをつける必要があります．<BLOCKQUOTE><PRE>print $line, &quot;\n&quot;;</PRE></BLOCKQUOTE></BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="SortST"><HR></A><H2>特定の項目でソートする</H2><BLOCKQUOTE><P>ここでは以下のようなデータに対するソートを例に説明します．<NOBR>1つ</NOBR><NOBR>1つ</NOBR>の要素は<NOBR>第 1〜3項</NOBR>をコンマで区切った形式をしています．<BLOCKQUOTE><PRE>@data = ('A,7,緑',         'C,6,青',         'B,4,赤',         'A,9,紫',         'A,2,黄緑',         'B,10,黄',         'C,3,青紫');</PRE><HR></BLOCKQUOTE><BLOCKQUOTE><B><PRE># 第 2項でソートする@data = map {$_-&gt;[0]}            sort {$a-&gt;[2] &lt;=&gt; $b-&gt;[2]}                 map {[$_, split /,/]} @data;</PRE></B><PRE>ソート後のデータ@data = ('A,2,黄緑',         'C,3,青紫',         'B,4,赤',         'C,6,青',         'A,7,緑',         'A,9,紫',         'B,10,黄');</PRE></BLOCKQUOTE><P>この方法は <FONT COLOR="Red">Schwartzian Transform</FONT>と呼ばれている方法です．このスクリプトはデータを要素の<NOBR>第 2項</NOBR>の数字の部分でソートしています．ソートを行なうには<NOBR><CODE>sort</CODE> 関数</NOBR>を使えばいいのですが，もとの要素のままではアルファベット，数字，色がコンマで区切られた<NOBR>1つ</NOBR>の文字列になってしまっているので，数字の部分だけでソートすることができません．そこで，要素から数字の部分を抜き出してソートする必要があります．要素から数字の部分を抜き出してソートするには次のように書けばできます．<BLOCKQUOTE><PRE>@data = sort {  my ($alpha_a, $num_a, $color_a) = split(/,/, $a);  my ($alpha_b, $num_b, $color_b) = split(/,/, $b);  $num_a &lt;=&gt; $num_b;} @data;</PRE></BLOCKQUOTE><P>しかし，この方法は<FONT COLOR="Red">非常に効率が悪い</FONT>ものです．なぜならば，比較が行なわれるたびに要素を分解しているからです．そこで，あらかじめ要素を分解しておき，比較するときに余計な処理をさせないことが重要となります．要素を分解，比較，もとの要素に戻すということを<FONT COLOR="Blue">一度に効率的に</FONT>やってしまうのがSchwartzian Transform です．<P>最初のスクリプトに戻って説明します．ソートは <NOBR>3行</NOBR>に渡って書かれていますが，これで <NOBR>1文</NOBR>です．実際の実行は<NOBR>3行目，</NOBR> <NOBR>2行目，</NOBR> <NOBR>1行目</NOBR>の順番で行なわれます．それぞれ，要素を分解，比較，もとの要素に戻すということをやっています．まず，<NOBR>3行目</NOBR>でデータの <NOBR>1つ</NOBR><NOBR>1つ</NOBR>の要素に対して，<FONT COLOR="Blue">無名配列へのリファレンス</FONT>を作って，これを要素とする新たな配列に変換しています．新しい要素は<NOBR><CODE>[$_, split /,/]</CODE></NOBR> です．これは簡単に言ってしまえば，<NOBR>(もとの要素, 第 1項, 第 2項, 第 3項)</NOBR> という配列だと思えばいいでしょう．次に，<NOBR>2行目</NOBR>で実際にソートします．<NOBR><CODE>$a-&gt;[2]</CODE></NOBR> や <NOBR><CODE>$b-&gt;[2]</CODE></NOBR>は，<NOBR>3行目</NOBR>であらかじめ分解して新しい要素に変換した無名配列の<NOBR>添え字 2</NOBR>の要素，つまり，<NOBR>第 2項</NOBR> を表わしています．ここでは要素を取り出しているだけなので，毎回分解していたやり方に比べて<FONT COLOR="Blue">効率がよい</FONT>ことがわかると思います．最後に <NOBR>1行目</NOBR>でもとの要素に戻しています．<P>Schwartzian Transform には，毎回分解していたやり方に比べて効率がよい，無名配列を使うことによって中間データを保持するため作業用の配列を特別に用意する必要がない，すべての処理を<FONT COLOR="Red">簡潔に記述</FONT>することができるといった特徴があります．しかし，無名配列を使用しているために，無名配列から要素を取り出すというオーバーヘッドが生じてしまいます．このため，次のように作業用の配列を用意して行なう方法の方が<FONT COLOR="Red">実行速度が速い</FONT>です．<BLOCKQUOTE><B><PRE># 第 2項でソートする(作業用配列を使った高速版)@tmp = map {(split /,/)[1]} @data;@data = @data[sort {$tmp[$a] &lt;=&gt; $tmp[$b]} 0 .. $#tmp];</PRE></B></BLOCKQUOTE><P>このスクリプトは，最初に<NOBR>作業用配列 <CODE>@tmp</CODE></NOBR>に<NOBR>第 2項</NOBR>を取り出しておき，配列の添え字のリスト値<NOBR><CODE>0 .. $#tmp</CODE></NOBR> に対してソートを行ない，ソートされた添え字をもとに<FONT COLOR="Blue">配列スライス</FONT>で<NOBR><CODE>@data</CODE></NOBR> からリスト値を取り出すことでソートしています．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="SortMulti"><HR></A><H2>複数の項目でソートする</H2><BLOCKQUOTE><P>ここでは以下のようなデータに対するソートを例に説明します．<NOBR>1つ</NOBR><NOBR>1つ</NOBR>の要素は<NOBR>第 1〜3項</NOBR>をコンマで区切った形式をしています．<BLOCKQUOTE><PRE>@data = ('A,7,緑',         'C,6,青',         'B,4,赤',         'A,9,紫',         'A,2,黄緑',         'B,10,黄',         'C,3,青紫');</PRE><HR></BLOCKQUOTE><BLOCKQUOTE><B><PRE># 第 1項でソートし，さらに第 2項で降順ソートする@data = map {$_-&gt;[0]}            sort {$a-&gt;[1] cmp $b-&gt;[1] or $b-&gt;[2] &lt;=&gt; $a-&gt;[2]}                 map {[$_, split /,/]} @data;</PRE></B><PRE>ソート後のデータ@data = ('A,9,紫',         'A,7,緑',         'A,2,黄緑',         'B,10,黄',         'B,4,赤',         'C,6,青',         'C,3,青紫');</PRE></BLOCKQUOTE><P>このスクリプトは，まず<NOBR>第 1項</NOBR>のアルファベットでソートし，同じアルファベットの中ではさらに<NOBR>第 2項</NOBR>の数字を比較して降順になるようにソートしています．基本的な動作は「<A HREF="#SortST">特定の項目でソートする</A>」で説明した内容と同じです．違いは <NOBR>2行目</NOBR>の <NOBR><CODE>sort</CODE> 関数</NOBR>の中だけです．複数の項目でソートしたい場合は，このようにソート条件を<FONT COLOR="Red"><CODE>or</CODE></FONT> を使って並べてやるだけです．<NOBR>第 1項</NOBR>のアルファベットでソートするときは<FONT COLOR="Blue">文字列の比較</FONT>になりますので<FONT COLOR="Red"><CODE>cmp</CODE></FONT> を使います．<NOBR>第 2項</NOBR>は<FONT COLOR="Blue">数字の比較</FONT>になりますので<FONT COLOR="Red"><NOBR><CODE>&lt;=&gt;</CODE></NOBR></FONT> を使います．また，<NOBR>第 2項</NOBR>は<FONT COLOR="Blue">降順</FONT>でソートしたいので， <NOBR><CODE>$a</CODE></NOBR> と <NOBR><CODE>$b</CODE></NOBR>を<FONT COLOR="Blue">左右逆</FONT>にしなければなりません．<P>上のスクリプトを作業用配列を使って実行速度が速くなるようにしたものが次のスクリプトになります．<BLOCKQUOTE><B><PRE># 第 1項でソートし，さらに第 2項で降順ソートする(作業用配列を使った高速版)@tmp1 = @tmp2 = ();foreach (@data) {  my ($first, $second) = split /,/;  push(@tmp1, $first);  push(@tmp2, $second);}@data = @data[sort {$tmp1[$a] cmp $tmp1[$b] or			$tmp2[$b] &lt;=&gt; $tmp2[$a]} 0 .. $#tmp1];</PRE></B></BLOCKQUOTE><P>このスクリプトの基本的な動作は「<A HREF="#SortST">特定の項目でソートする</A>」で説明した内容と同じです．簡潔に記述したいのであれば Schwartzian Transform ですが，実行速度を速くしたいのであれば簡潔に記述することをあきらめるしかないようです．<P>おまけとして，数字で始まる文字列を含まない任意の項目数のデータを昇順で多重ソートするスクリプトを載せておきます．このスクリプトは<NOBR>perl5.005</NOBR> 以降でしか動作しませんが，<NOBR><CODE>expr foreach ()</CODE></NOBR> の形を<NOBR><CODE>foreach () {expr}</CODE></NOBR> の形にすれば，<NOBR>perl5.005</NOBR> 以前の <NOBR>perl5</NOBR> でも動作するようになります．<BLOCKQUOTE><B><PRE># 任意の項目数のデータを昇順で多重ソートする@data = map {$_-&gt;[0]}            sort {$x = ($a-&gt;[$_] &lt;=&gt; $b-&gt;[$_] or $a-&gt;[$_] cmp $b-&gt;[$_])		    and return $x foreach (1 .. $#$a); -1}                 map {[$_, split /,/]} @data;</PRE></B></BLOCKQUOTE></BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="SortOriginal"><HR></A><H2>自分で決めた順番でソートする</H2><BLOCKQUOTE><P>ここでは以下のようなデータに対するソートを例に説明します．<NOBR>1つ</NOBR><NOBR>1つ</NOBR>の要素は<NOBR>第 1〜3項</NOBR>をコンマで区切った形式をしています．<BLOCKQUOTE><PRE>@data = ('A,7,緑',         'C,6,青',         'B,4,赤',         'A,9,紫',         'A,2,黄緑',         'B,10,黄',         'C,3,青紫');</PRE><HR></BLOCKQUOTE><BLOCKQUOTE><B><PRE># 第 3項が自分で決めた順番になるようにソートする$i = 0;undef(%color);foreach $name ('赤', '黄赤', '黄', '黄緑', '緑', '青緑', '青', '青紫',               '紫', '赤紫') {  $color{$name} = $i++;}@data = map {$_-&gt;[0]}            sort {$color{$a-&gt;[3]} &lt;=&gt; $color{$b-&gt;[3]}}                 map {[$_, split /,/]} @data;</PRE></B><PRE>ソート後のデータ@data = ('B,4,赤',         'B,10,黄',         'A,2,黄緑',         'A,7,緑',         'C,6,青',         'C,3,青紫',         'A,9,紫');</PRE></BLOCKQUOTE><P>ソートの基本的な動作は「<A HREF="#SortST">特定の項目でソートする</A>」で説明した内容と同じです．自分で決めた順番でソートするためには，その順番を数字に変換できるように<FONT COLOR="Blue">ハッシュに定義</FONT>しておき，あとはその数字を使ってソートするだけです．このスクリプトでは，<NOBR>第 3項</NOBR>の色が赤，黄赤，黄，黄緑，緑，青緑，青，青紫，紫，赤紫という順番になるようにソートしています．色の名前のままではソートすることはできませんので，順に <NOBR>0〜9</NOBR> の数字に対応するようにハッシュを定義しています．ソートするときは，このハッシュから対応する数字に変換し，数字の比較でソートします．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="Date2WDay"><HR></A><H2>年月日から曜日を求める</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># $year年 $mon月 $mday日の曜日を求めるuse Time::Local;$time = timelocal(0, 0, 0, $mday, $mon - 1, $year - 1900);($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =  localtime($time);$wday_string = (qw(日 月 火 水 木 金 土))[$wday];</PRE></B></BLOCKQUOTE><P><NOBR><CODE>timelocal</CODE> 関数</NOBR>を使って，まずは年月日時分秒を1970年1月1日00時00分00秒からの秒数(MacPerl では1904年1月1日00時00分00秒からの秒数)に変換します．このとき年と月の引数はそれぞれ <FONT COLOR="Red"><NOBR><CODE>- 1900</CODE></NOBR></FONT>，<FONT COLOR="Red"><NOBR><CODE>- 1</CODE></NOBR></FONT>する必要があります．次に，その秒数から<NOBR><CODE>localtime</CODE> 関数</NOBR>を使って曜日<NOBR><CODE>$wday</CODE> (<FONT COLOR="Blue">0〜6</FONT>)</NOBR>を求めます．最後にその数字を文字列に変換してあげます．<P>通常は上の書き方で問題ないのですが，<FONT COLOR="Red">ほとんどの計算機で <NOBR>1970年〜2037年</NOBR>までしか計算できない</FONT>という制限があります．そこで，この範囲を超えるような場合があるときは<NOBR>ツェラー(Zellar)</NOBR>の公式というものを使って次のように書きます．ツェラーの公式を使えば<FONT COLOR="Blue">制限はありません</FONT>し，<FONT COLOR="Blue">実行速度も速い</FONT>のですが，すぐに思い出せない，覚えられないという欠点があります．<BLOCKQUOTE><B><PRE># $year年 $mon月 $mday日の曜日を求める$wday = getwday($year, $mon, $mday);$wday_string = (qw(日 月 火 水 木 金 土))[$wday];sub getwday {  my($year, $mon, $mday) = @_;  if ($mon == 1 or $mon == 2) {    $year--;    $mon += 12;  }  int($year + int($year / 4) - int($year / 100) + int($year / 400)      + int((13 * $mon + 8) / 5) + $mday) % 7;}</PRE></B></BLOCKQUOTE></BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="Time2Date"><HR></A><H2>一週間前の年月日を求める</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># 一週間前の年月日($year年 $mon月 $mday日)を求めるuse Time::Local;# 一週間前の時間を求める$time = time() - 60 * 60 * 24 * 7;($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =    localtime($time);$year += 1900;$mon++;</PRE></B></BLOCKQUOTE><P>現在の時間を <NOBR><CODE>time</CODE> 関数</NOBR>で求め，その秒数から一週間前の時間になるように <NOBR><CODE>60 * 60 * 24 * 7</CODE></NOBR> を引いてあげます．この秒数を <NOBR><CODE>localtime</CODE> 関数</NOBR>を使って年月日に変換します．<NOBR><CODE>localtime</CODE> 関数</NOBR>が返す値は，年が西暦から<FONT COLOR="Red">1900を引いた値</FONT>で，月は<FONT COLOR="Red"><NOBR>0〜11</NOBR>までの値</FONT>を返します．したがって，最後に年と月をそれぞれ<FONT COLOR="Blue"><NOBR>+ 1900</NOBR></FONT>，<FONT COLOR="Blue"><NOBR>+ 1</NOBR></FONT>する必要があります．<NOBR><CODE>time</CODE> 関数</NOBR>を返す値を大きくすれば未来の年月日を求めることができます．<P>年月日や時間に関する<A HREF="http://search.cpan.org/search?dist=Date-Calc"><NOBR>モジュール <CODE>Date::Calc</CODE></NOBR></A>を使っても同じようなことができますが，標準のモジュールではないためアーカイブファイルを取ってきてインストールする必要があります．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="Date2Last"><HR></A><H2>年月から末日を求める</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># $year年 $mon月の末日 $lastday を求める$lastday = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)[$mon - 1]           + ($mon == 2 and $year % 4 == 0 and	      ($year % 400 == 0 or $year % 100 != 0));</PRE></B></BLOCKQUOTE><P>最初の行は <NOBR>1月</NOBR>から <NOBR>12月</NOBR>までの末日を並べた<FONT COLOR="Blue">リスト値</FONT>に対して，添え字 <NOBR><CODE>$mon - 1</CODE></NOBR> に対応する値を取り出しています．<NOBR>2行目</NOBR>，<NOBR>3行目</NOBR>は閏年のための補正です．基本的に 4で割れる年は閏年だが，100で割れる年のときは閏年ではない，ただし，400で割れる年は閏年である．言い換えると，4で割れる年のうち<FONT COLOR="Blue"><CODE>and (</CODE></FONT>400で割れる年と <FONT COLOR="Blue"><CODE>or</CODE></FONT>100で割れない年 <FONT COLOR="Blue">)</FONT> が閏年ということになります．閏年の <NOBR>2月</NOBR>の末日を計算するときという条件を表わしたものが<NOBR>2行目</NOBR>，<NOBR>3行目</NOBR>です．<P>Perlでは <CODE>and</CODE> や <CODE>or</CODE> は，<FONT COLOR="Red">最後に評価した値</FONT>を返します．また，<NOBR><CODE>==</CODE></NOBR> や <NOBR><CODE>!=</CODE></NOBR> は真のときに<FONT COLOR="Red">1</FONT>，偽のときに<FONT COLOR="Red">空文字列</FONT>を返します．このことから，<NOBR>2行目</NOBR>，<NOBR>3行目</NOBR>の条件式は閏年の<NOBR>2月</NOBR>の末日を計算するときは 1，そうでないときは空文字列を返すことになります．これをリスト値から取り出した末日に加えます．<CODE>+</CODE> は数値の和を求める演算子ですので，空文字列のときは数値として解釈できないので 0 に変換されます．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="NthW2Date"><HR></A><H2>第N W曜日の日付を求める</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># $year年 $mon月の第$n $wday(0-6)曜日が何日か求める# getwday() は別途参照$wday1 = getwday($year, $mon, 1);$mday = 1 + ($wday - $wday1) % 7 + 7 * ($n - 1);print $mday, &quot;\n&quot;;</PRE></B></BLOCKQUOTE><P>まず初めに，その月の <NOBR>1日</NOBR>の曜日 <NOBR><CODE>$wday1</CODE></NOBR>を求めます．年月日から曜日を求める方法については，「<A HREF="#Date2WDay">年月日から曜日を求める</A>」を参照してください．<P>次に <NOBR>1日</NOBR>を基準に求めたい日付を計算します．求めたい曜日 <NOBR><CODE>$wday</CODE></NOBR> と <NOBR>1日</NOBR>の曜日<NOBR><CODE>$wday1</CODE></NOBR> の差を加えてあげれば<NOBR>第1 <CODE>$wday</CODE>曜日</NOBR>の日付を求めることができます．しかし，ここで単純に加えたのでは差が負数の場合にまずいことになります．そこで <NOBR><CODE>if</CODE> 文</NOBR>で場合分けしてもよいのですが，7 で割った余り(必ず非負数)を求めれば，うまく<NOBR>第1 <CODE>$wday</CODE>曜日</NOBR>の日付を求めることができます．最後に <NOBR><CODE>$n</CODE>番目</NOBR>の <NOBR><CODE>$wday</CODE>曜日</NOBR>の日付を求めるために <NOBR><CODE>7 * ($n - 1)</CODE></NOBR> を加えて終わりです．<P>求めた日付が本当に存在するかどうかは，「<A HREF="#Date2Last">年月から末日を求める</A>」で書いたように末日を求めて比較すればよいことになります．<P>年月日や時間に関する<A HREF="http://search.cpan.org/search?dist=Date-Calc"><NOBR>モジュール <CODE>Date::Calc</CODE></NOBR></A>を使っても同じようなことができますが，標準のモジュールではないためアーカイブファイルを取ってきてインストールする必要があります．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="NumberWithComma"><HR></A><H2>数字を 3桁ごとにコンマで区切る</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE>1 while s/^([-+]?\d+)(\d\d\d)/$1,$2/;</PRE></B></BLOCKQUOTE><P>このスクリプトの <CODE>while</CODE> の前の <CODE>1</CODE> は特に意味がない<FONT COLOR="Blue">ダミー</FONT>の式です．本当に行ないたい部分は<NOBR><CODE>while</CODE> 文</NOBR>の<FONT COLOR="Red">条件式</FONT>の部分の置換です．このスクリプトは，置換が行なわれると条件式が真になり，ダミーの式である<CODE>1</CODE> を実行し，再び置換を行なおうとします．置換が行なわれるとコンマが<NOBR>1つ</NOBR>追加されます．つまり，コンマを <NOBR>1つ</NOBR>ずつ追加していき，追加できなくなった時点で <NOBR><CODE>while</CODE> 文</NOBR>が終了することになります．<P>では，実際にどのように置換しコンマを追加しているのか説明します．<NOBR><CODE>^([-+]?\d+)</CODE></NOBR> の部分が，数字を先頭から見て，符号を考慮にいれつつ数字である限りできるだけ伸ばそうとします．ところが，その後ろに<NOBR><CODE>(\d\d\d)</CODE></NOBR> というのがあるので，少なくとも数字を<NOBR>3つ</NOBR>残さなければパターンマッチできません．したがって，<NOBR><CODE>$1</CODE></NOBR> には後ろに数字を <NOBR>3つ</NOBR>残した前の部分の数字，<NOBR><CODE>$2</CODE></NOBR> には残された<NOBR>3つ</NOBR>の数字が代入されることになります．その間にコンマを入れてあげます．これでコンマが<NOBR>1つ</NOBR>追加されます．これを繰り返すことで数字全体に対して <NOBR>3桁</NOBR>ごとにコンマで区切ることができます．つまり，このスクリプトでは数字を<FONT COLOR="Blue">桁の小さい方から</FONT><NOBR>3桁</NOBR>ずつ大きい方に向かって区切っています．<P><NOBR><CODE>while</CODE> 文</NOBR>を使った方法よりも，次のように書いた方が<FONT COLOR="Blue">桁が大きい場合には実行速度が速い</FONT>です．<BLOCKQUOTE><B><PRE>s/(\d{1,3})(?=(?:\d\d\d)+(?!\d))/$1,/g;</PRE></B></BLOCKQUOTE><P>このスクリプトは<FONT COLOR="Blue"><NOBR>修飾子<CODE>g</CODE></NOBR></FONT>を使うことで，置換文だけで数字をコンマで区切っています．コンマで区切る方法も<NOBR><CODE>while</CODE> 文</NOBR>を使った置換と違い，<FONT COLOR="Blue">桁の大きい方から</FONT>区切っています．どのように区切っているのか説明します．<P>ここで一番注目しなければいけないのが，<NOBR><CODE>(?=regex)</CODE></NOBR> の部分です．これは正規表現<CODE>regex</CODE> にマッチする文字列が<FONT COLOR="Red">次にくる場合</FONT>にマッチする <FONT COLOR="Red"><NOBR>0文字幅</NOBR></FONT>の正規表現です．<NOBR>「0文字幅」</NOBR>というのは，文字列の先頭や最後を表わす <CODE>^</CODE> や <CODE>$</CODE>のように，文字としての幅がないという意味です．ちょうど <NOBR><CODE>\b</CODE></NOBR>が単語の境界にマッチするように，<NOBR><CODE>(?=regex)</CODE></NOBR> も文字と文字の間でマッチするものと考えるといいでしょう．「次にくる場合」というのは，たとえば<NOBR><CODE>foo(?=bar)</CODE></NOBR> という正規表現の場合，<CODE>foo</CODE>や <CODE>foohoge</CODE>などはマッチしません．なぜなら <CODE>foo</CODE> の次に <CODE>bar</CODE>がこないからです．<CODE>foobar</CODE> の場合はマッチするわけですが，マッチするのは<CODE>foo</CODE> の部分だけです．<NOBR><CODE>(?=bar)</CODE></NOBR> は次に<CODE>bar</CODE> がこなければならないと言っているだけで <CODE>bar</CODE> を含んでいるわけではないからです．これが正規表現 <CODE>foobar</CODE> と<NOBR><CODE>foo(?=bar)</CODE></NOBR>の違いです．<NOBR><CODE>(?!regex)</CODE></NOBR> は<NOBR><CODE>(?=regex)</CODE></NOBR> の否定の形で，<FONT COLOR="Red">次にこない場合</FONT>にマッチします．<P>話をスクリプトに戻しますと，<NOBR><CODE>(?=(?:\d\d\d)+(?!\d))</CODE></NOBR>は数字が<FONT COLOR="Blue">次にこない</FONT>ような，<NOBR>3桁</NOBR>の数字の<NOBR>1回</NOBR>以上の繰り返しが<FONT COLOR="Blue">次にくる</FONT>ことを表わしています．数字が次にこないということは数字の終わりを意味しています．<CODE>$</CODE> と違って文字列の最後でなくても数字が終わっている部分にマッチするということです．全体として，桁の小さい方から<NOBR>3桁</NOBR>ずつ数字をまとめているわけです．ただし，<NOBR><CODE>(?=regex)</CODE></NOBR> ですので，<NOBR>3桁</NOBR>ずつ数字をまとめたものが次にくると言っているだけで，それを含んでしまっているわけではありません．そして，一番桁の大きい部分が<NOBR><CODE>(\d{1,3})</CODE></NOBR> にマッチします．この部分の後ろにコンマを追加します．これで <NOBR>1つ</NOBR>コンマが追加されたわけですが，<NOBR>修飾子 <CODE>g</CODE></NOBR> によって他にも置換できるところをすべて置換しにいきます．このときに先ほど「含んでいない」と言った部分が効いてきます．最初の置換で実際にマッチした数字は一番桁の大きい部分のところです．次に<NOBR>修飾子<CODE>g</CODE></NOBR> によって他のところを置換しにいくときは，このマッチした部分の次から置換を始めようとします．もし，含んでしまっていたら，数字全体にマッチしてしまいますので，コンマが <NOBR>1つ</NOBR>しか追加されずに終了してしまいます．<P>このスクリプトでは小数のことを考えていないので，小数点以下の部分までコンマで区切ってしまうという問題点があります．これを修正したものが次のスクリプトです．<BLOCKQUOTE><B><PRE>s/\G((?:^[-+])?\d{1,3})(?=(?:\d\d\d)+(?!\d))/$1,/g;</PRE></B></BLOCKQUOTE><P><NOBR><CODE>\G</CODE></NOBR>は<FONT COLOR="Red">パターンマッチの開始位置にマッチ</FONT>します．これが入っていることで，いきなり小数点以下部分にマッチしたりすることがなくなり，前回マッチした部分のすぐ次の桁からの部分にだけ注目して置換を行なうことができるようになります．<NOBR><CODE>\G</CODE></NOBR> のことは「<A HREF="#JP_Match">正しくパターンマッチさせる</A>」の中でも触れています．<P>実行速度ですが，私がベンチマークをとって調べたところ，<NOBR>2番目</NOBR>の方法よりもその修正版である <NOBR>3番目</NOBR>の方法の方があらゆる場合において実行速度が速かったです．<NOBR>1番目</NOBR>の方法と <NOBR>3番目</NOBR>の方法ですが，<NOBR>6桁</NOBR>以上の数字においては<NOBR>3番目</NOBR>の方法の方が実行速度が速かったです．<NOBR>5桁</NOBR>以下では <NOBR>1番目</NOBR>の方法が一番速かったのです．<P>もし，実行速度を気にするのであれば，次のように書く方法があります．実行速度は上記のどの方法よりも<FONT COLOR="Red">速い</FONT>です．符号や小数にも対応しています．<BLOCKQUOTE><B><PRE># $num を3桁ごとにコンマで区切る(高速版)$num = reverse(join(',', reverse($num) =~ /((?:^\d+\.)?\d{1,3}[-+]?)/g))  if $num =~ /^[-+]?\d\d\d\d/;</PRE></B></BLOCKQUOTE><P>このスクリプトは数字を一旦ひっくり返してから，前から<NOBR>3桁</NOBR>ごとに区切り，それらをコンマで連結した上で再度ひっくり返しています．このスクリプトのように複雑な正規表現を避けたり，パターンマッチ文の評価回数を少なくしたりすることで実行速度を速くできる場合があります．<NOBR><CODE>if</CODE> 文</NOBR>ですが，これがなくても動作します．しかし，その場合は <NOBR>3桁</NOBR>以下の場合，つまり，全くコンマで区切る必要がない場合においても，数字をひっくり返してから元に戻すという作業が発生してしまい実行速度が遅くなってしまいます．<NOBR><CODE>if</CODE> 文</NOBR>は数字の絶対値が 1000以上であるとしてもいいのですが，私がベンチマークをとってみたところ，このスクリプトのように正規表現で判断した方が実行速度が速かったです．ただ，一般にパターンマッチは遅いものなので，他の組み込み関数で簡単に代用できる場合は正規表現を避けた方が実行速度が速くなることが多いです．<P>次のスクリプトは複雑な正規表現を避け，組み込み関数で代用するということを更に進めたものです．<FONT COLOR="Red">実行速度は最速</FONT>です．もちろん，符号や小数にも対応しています．<BLOCKQUOTE><B><PRE># $num を3桁ごとにコンマで区切る(最速版)if ($num =~ /^[-+]?\d\d\d\d+/g) {  for ($i = pos($num) - 3, $j = $num =~ /^[-+]/; $i &gt; $j; $i -= 3) {    substr($num, $i, 0) = ',';  }}</PRE></B></BLOCKQUOTE><P>このスクリプトはまず初めに <NOBR><CODE>if</CODE> 文</NOBR>で，全くコンマで区切る必要がない場合に無駄な処理をさせないという判断を行なうと同時に，どこまでが整数部分であるのかということもチェックしています．正規表現の最後に<CODE>+</CODE> がつけてあるので小数点が来るか，または，文字列の最後に達するかするまでできるだけ長くマッチしようとします．したがって，この正規表現で整数部分がすべてマッチすることになります．<P>このパターンマッチにおいてに<FONT COLOR="Red"><NOBR>修飾子 <CODE>g</CODE></NOBR></FONT>がつけられているところに注意してください．<NOBR>修飾子 <CODE>g</CODE></NOBR> をつけたパターンマッチをスカラーコンテキストで評価した場合，パターンマッチ対象となった文字列は前回マッチした場所を記憶しています．そのため，もう一度同じ文字列に対して<NOBR>修飾子 <CODE>g</CODE></NOBR> をつけたパターンマッチを行なうと，続きからパターンマッチが行なわれるようになります．このスクリプトでは<NOBR><CODE>pos</CODE> 関数</NOBR>によって前回マッチした場所の記憶，すなわち，整数部分が文字列のどの位置までかということを取得しています．この情報を使ってコンマを追加することで小数点以下の場所までコンマを追加することがなくなります．<P>整数部分の最後の場所がわかれば，後は <NOBR>3文字</NOBR>ごとにコンマを追加していくことになります．このスクリプトでは追加の作業を <NOBR><CODE>substr</CODE>関数</NOBR>で行なっています．この関数の<NOBR>第 3引数</NOBR>が <CODE>0</CODE>なので文字と文字の間に文字列，この場合は，コンマを追加することになります．このとき単純に <NOBR>3文字</NOBR>ごとに追加していったのでは，符号がついていた場合に符号と数字の間に間違ってコンマを追加してしまう場合があります．そのため，符号がついていた場合には符号を含めないように処理を止めるようにしています．具体的には，<NOBR><CODE>$j</CODE></NOBR> の値は符号がついていなければ<FONT COLOR="Red">空文字列</FONT>，符号がついていれば<CODE>1</CODE> になります．空文字列は比較するときには <CODE>0</CODE>と解釈されます．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="NumberRound"><HR></A><H2>数字を四捨五入する</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># $num を四捨五入して小数点以下 $decimals桁にするsub round {  my ($num, $decimals) = @_;  my ($format, $magic);  $format = '%.' . $decimals . 'f';  $magic = ($num &gt; 0) ? 0.5 : -0.5;  sprintf($format, int(($num * (10 ** $decimals)) + $magic) /                   (10 ** $decimals));}</PRE></B><PRE># 計算例$number = 1.2345;$number_0 = round($number, 0);  # 四捨五入して整数にする$number_2 = round($number, 2);  # 小数点以下2桁まで求める$number_3 = round($number, 3);  # 小数点以下3桁まで求めるprint $number_0, &quot;\n&quot;;          # --&gt; 1print $number_2, &quot;\n&quot;;          # --&gt; 1.23print $number_3, &quot;\n&quot;;          # --&gt; 1.235</PRE></BLOCKQUOTE><P>四捨五入の基本は，正数の小数点以下を四捨五入して正整数にすることです．これをやるには，<NOBR>0.5</NOBR> を加えて<NOBR><CODE>int</CODE> 関数</NOBR>で小数点以下を削除すればできます．小数点以下 <NOBR>n 桁</NOBR>のところで四捨五入したい場合は，まず 10 の<NOBR>(n - 1) 乗</NOBR>します．これで四捨五入したい桁の部分が<NOBR>小数第 1位</NOBR>のところにきます．あとは基本どおりに四捨五入し，今度は 10 の<NOBR>-(n - 1) 乗</NOBR>してもとの桁に戻します．負数の場合は，<NOBR>0.5</NOBR> を加えるのではなく引くというところが違い，あとは正数の場合と同じです．<P>こうして求めた数値はそのままでは正確に求めたい桁数になっていない場合があります．そこで最後に<NOBR><CODE>sprintf</CODE> 関数</NOBR>を使って不要な桁を削除しています．<P>単に小数点以下の特定の桁までに数字を丸めたい場合には，次にように<CODE>sprintf</CODE> の <NOBR><CODE>%f</CODE></NOBR> を使えば可能です．<BLOCKQUOTE><PRE># $num を小数点以下 $decimals桁までに丸める(完全な四捨五入ではない)$num = sprintf("%.${decimals}f", $num);</PRE></BLOCKQUOTE><P>完全な四捨五入ではないと書いたのは，特定の条件下では結果が四捨五入とならないからです．例えば 0.15を小数第2位で四捨五入して，小数点以下1桁までにした結果の 0.2 を期待して，<NOBR><CODE>printf("%.1f\n", 0.15);</CODE></NOBR> と書いても，ほとんどの環境で 0.2 とはならずに 0.1 と表示されることでしょう．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="NumberCeil"><HR></A><H2>数字を切り上げる</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># $num を切り上げて小数点以下 $decimals桁にするsub ceil {  my ($num, $decimals) = @_;  my ($format, $tmp1, $tmp2);  $format = '%.' . $decimals . 'f';  $tmp1 = $num * (10 ** $decimals);  $tmp2 += $tmp1 &lt;=&gt; ($tmp2 = int($tmp1));  sprintf($format, $tmp2 / (10 ** $decimals));}</PRE></B><PRE># 計算例$number = 1.2345;$number_0 = ceil($number, 0);  # 切り上げて整数にする$number_2 = ceil($number, 2);  # 小数点以下2桁まで求める$number_3 = ceil($number, 3);  # 小数点以下3桁まで求めるprint $number_0, &quot;\n&quot;;          # --&gt; 2print $number_2, &quot;\n&quot;;          # --&gt; 1.24print $number_3, &quot;\n&quot;;          # --&gt; 1.235</PRE></BLOCKQUOTE><P>このスクリプトの基本は「<A HREF="#NumberRound">数字を四捨五入する</A>」のスクリプトと同じです．実際に切り上げを行なっている部分は，<NOBR><CODE>sprintf</CODE> 関数</NOBR>の直前の文です．この文をわかりやすく書きかえると次のようになります．<BLOCKQUOTE><PRE>  $tmp2 = int($tmp1) + ($tmp1 &lt;=&gt; int($tmp1));</PRE></BLOCKQUOTE><P>これは，小数点以下を切り落とした数字と元の数字を比較して，もし違えば切り上げるということを行なっています．切り上げる方向は絶対値が大きくなる方向です．<P><NOBR>モジュール <CODE>POSIX</CODE></NOBR> の <NOBR><CODE>ceil</CODE>関数</NOBR>を使えば切り上げを行なうことができますが，この関数は切り上げて整数にすることしかやってくれません．また，切り上げる方向は正の方向ですので，負数を切り上げる場合には注意が必要です．</BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="ArrayUnique"><HR></A><H2>配列から重複した要素を取り除く</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># 配列 @array から重複した要素を取り除く{  my %count;  @array = grep(!$count{$_}++, @array);}</PRE></B></BLOCKQUOTE><P>このようにすると配列の要素の<FONT COLOR="Blue">出現順序が保存</FONT>されます．また，<NOBR>ハッシュ <CODE>%count</CODE></NOBR> には配列の要素をキーとし，その値には出現回数が入っています．出現回数の否定を条件式とすることで重複した要素を取り除くことができます．具体的には，初めて出現したときは出現回数を <NOBR>0回</NOBR>から <NOBR>1回</NOBR>に<NOBR><CODE>++</CODE></NOBR> するわけですが，そのときの条件式は <NOBR><CODE>!0</CODE></NOBR> となり真となります．次に出現したとき，つまり，重複していたときは，<NOBR>出現回数 1</NOBR>以上の数値に対しての否定となり必ず偽となります．<P><NOBR>ハッシュ <CODE>%count</CODE></NOBR> は局所化されていますので，このブロックを抜けた時点で<FONT COLOR="Blue">自動的に消滅</FONT>します．もし，出現回数を利用したいのであれば，このブロック内で利用するか，または，次のように書くことで後から利用することができます．<BLOCKQUOTE><B><PRE># 配列 @array から重複した要素を取り除く# 後から出現回数を利用したいundef(%count);@array = grep(!$count{$_}++, @array);</PRE></B></BLOCKQUOTE></BLOCKQUOTE><A HREF="#Top">トップへ</A><A NAME="ArrayRandom"><HR></A><H2>配列をランダムに並び替える</H2><BLOCKQUOTE><BLOCKQUOTE><B><PRE># 配列 @array をランダムに並び替えるsrand;for (my $i = @array; --$i; ) {  my $j = int rand ($i + 1);  next if $i == $j;  @array[$i, $j] = @array[$j, $i];}</PRE></B></BLOCKQUOTE><P><NOBR><CODE>srand</CODE> 関数</NOBR>は <NOBR><CODE>rand</CODE>関数</NOBR>を使う前に<FONT COLOR="Red">一度だけ</FONT>実行しておく必要があります．もし，<NOBR><CODE>srand</CODE> 関数</NOBR>を実行しておかないといつも同じ結果になってしまいます．ただ，<NOBR>perl5.004</NOBR> 以降では <NOBR><CODE>rand</CODE>関数</NOBR>が使われたときに，まだ一度も <NOBR><CODE>srand</CODE></NOBR> 関数を実行していなかった場合には<FONT COLOR="Red">自動で実行してくれます</FONT>．<NOBR><CODE>$i = @array</CODE></NOBR> では<NOBR><CODE>@array</CODE></NOBR>が<FONT COLOR="Red">スカラーコンテキスト</FONT>で実行されますので，<FONT COLOR="Blue">配列の大きさ</FONT>を返します．このスクリプトの <NOBR><CODE>for</CODE> 文</NOBR>は<NOBR>(配列の大きさ - 1)回</NOBR>実行され，<NOBR><CODE>for</CODE> 文</NOBR>のブロックの中の <NOBR>3つ</NOBR>目の文で要素の入れ替えを<FONT COLOR="Blue">配列スライス</FONT>を使って行なっています．<NOBR><CODE>$i</CODE></NOBR> の初期値は配列の大きさ，つまり，<NOBR>(最後の添え字の値 + 1)</NOBR> となっているのですが，<NOBR>条件文 <CODE>--$i</CODE></NOBR> が評価されるときに <NOBR>- 1</NOBR>されますので，<NOBR><CODE>for</CODE> 文</NOBR>のブロックの中に入るときには <NOBR>(最後の添え字の値)</NOBR> になっています．<P>もし，元の配列を残しておきたいのならば次のように書きます．<BLOCKQUOTE><B><PRE># 配列 @old をランダムに並び替えた配列 @new を作るsrand;@new = ();foreach (@old) {  my $r = int rand (@new + 1);  push(@new, $new[$r]);  $new[$r] = $_;}</PRE></B></BLOCKQUOTE><P>このスクリプトは配列の要素を入れ替えるという先ほどのスクリプトと違い，要素を <NOBR>1つ</NOBR>ずつ新しい配列に追加していくのですが，そのときに新しい要素はランダムに選んだ場所に入れ，もともとそこにあった要素を一番最後に移動させるというものです．</BLOCKQUOTE><A HREF="#Top">トップへ</A><HR><A HREF="index.htm">戻る</A><HR><TABLE><TR>  <TD><IMG SRC="uzura2.jpg" ALT="うずら" WIDTH=96 HEIGHT=88></TD>  <TD VALIGN="top">    <ADDRESS>      <A HREF="mailto:ohzaki@din.or.jp">ohzaki@din.or.jp</A>    </ADDRESS><!--    <ADDRESS><A HREF="mailto:CQE02013@nifty.ne.jp">    CQE02013@nifty.ne.jp</A></ADDRESS>    <ADDRESS><A HREF="mailto:hiroki.ohzaki@nifty.ne.jp">    hiroki.ohzaki@nifty.ne.jp</A></ADDRESS>-->  </TD></TR></TABLE><HR><U><I>Copyright (C) 1999-2002 OHZAKI Hiroki. All rights reserved.</I></U></BODY></HTML>